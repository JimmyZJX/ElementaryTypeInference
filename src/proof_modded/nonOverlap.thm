Import "trans".

Theorem mono_strenthen_tyvar : forall F E FE FxE A T, nabla x,
	append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
	mono (FxE x) T -> mono E A -> mono (FE A) T.
induction on 3. intros. case H3.
	search.
	assert member (tyvar n2) (FE n2 n1).
			apply append_mem_inv to H2 H5. case H6. backchain append_mem.
			case H7. backchain append_mem.
		apply mem_tyvar_subst to H6 with A = A. search.
	apply IH to H1 H2 H5 _. apply IH to H1 H2 H6 _. search.

Theorem mono_strenthen_tyvar_notfresh : forall F E FE FxE A T, nabla x,
	append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
	mono (FxE x) (T x) -> mono E A -> mono (FE A) (T A).
induction on 3. intros. case H3.
	search.
	assert member (tyvar n2) (FE n2 n1).
			apply append_mem_inv to H2 H5. case H6. backchain append_mem.
			case H7. backchain append_mem.
		apply mem_tyvar_subst to H6 with A = A. search.
	W: apply mono_wfta to H4.
		A: apply append_subst to H1 with A = A.
		W: apply mono_weaken_f to A _. search.
	apply IH to H1 H2 H5 _. apply IH to H1 H2 H6 _. search.

Theorem mono_nil_any : forall E m, mono nil m -> mono E m.
induction on 1. intros. case H1; try search; try solve (unfold; backchain IH); try case H2.

Theorem sub_tyvar_notall : forall E A, nabla x, % E0 does not have x
	sub (E x) (all (A x)) x -> member (styvar x) (E x) -> wfj (E x) -> false.
induction on 1. intros S Sty. S: case S (keep).
	applys mono_prune_styvar Sty.
		W: applys sub_wft S1.
		S: case S1 (keep).
			case S5. f: case S4. backchain f. case S2.
			case S5. f: case S4. backchain f. case S2.
			case S5. f: case S4. backchain f.
			case S5. f: case S4. backchain f.
			case S5. f: case S4. backchain f.
			applys mono_prune_styvar S7.
				case S5.
					applys IH S1 with A = x\ A2 x M.
					applys IH S1.


Theorem sub_subst_wft : forall E A B C, nabla x,
	wft (E x) C -> sub (E x) (A x) (B x) -> member (styvar x) (E x) -> wfj (E x) ->
	sub (E x) (A C) (B C).
induction on 2. intros W S Sty. S: case S (keep).
	search.
	W: applys wft_subst S1 W with T = A. search.
	W: applys wft_subst S1 W with T = B. search.
	search.
	backchain sub_refl.
	search.
	backchain sub_refl.
	S: applys IH S1. S: applys IH S2. search.
	applys mono_prune_styvar S2.
		notAll: assert notAll_ (B C) \/ B = x\ x.
			W: applys sub_wft S1.
			W: case W2; try search. applys notAll_false S3.
		S: applys IH.
		All: case notAll.
			W: applys sub_wft S. W: case W1.
				FV: applys inFV_subst W1 with A = A1, m = C.
				unfold. exists M.
				search.
			applys sub_tyvar_notall S.
	W: applys wft_weaken_f W with E = styvar n2 :: nil.
		S: applys IH W1 with x = n1.
		W: applys sub_wft S1.
		FV: applys inFV_subst W2 with A = A1, m = C.
		FV: applys inFV_subst W3 with A = B1, m = C.
		search.

Theorem mid_ty_det : forall F E FxE F' E', nabla (x : ty),
	append (F x) (tyvar x :: E) (FxE x) -> append (F' x) (tyvar x :: E') (FxE x) ->
	F = F' /\ E = E'.
induction on 1. intros. case H1; case H2.
	search. applys append_prune H3.
	applys append_prune H3.
	applys IH H4. search.

Theorem sub_substM : forall F E FxE FE A B m, nabla x,
	append (F x) (tyvar x :: E) (FxE x) -> append (F x) E (FE x) ->
	mono E m -> sub (FxE x) (A x) (B x) -> sub (FE m) (A m) (B m).
induction on 4. intros A A M S SE a. S: case S (keep).
	search.
	W: applys mono_wft M.
		W: applys wft_strenthen_tyvar_notfresh A1 A S1 W.
		search.
	W: applys mono_wft M.
		W: applys wft_strenthen_tyvar_notfresh A1 A S1 W.
		search.
	M: applys mem_FxE_FE A.
		M: applys mem_tyvar_subst M1 with A = m.
		search.
	A: applys append_subst A1 with A = m.
		M: applys mono_weaken_f A2.
		W: applys mono_wfta M.
		backchain sub_refl. backchain mono_wft.
	M: applys mem_FxE_FE A.
		W: applys mem_styvar_subst M1 with A = m.
		search.
	backchain sub_refl. backchain mono_wft.
		A: applys append_subst A1 with A = m.
		backchain mono_weaken_f.
	S: applys IH S1. S: applys IH S2. search.
	S: applys IH.
		M: applys mono_strenthen_tyvar_notfresh S2 M.
		W: applys sub_wft S.
		unfold. exists m1 m. split; try search.
			case W1; try search; try applys notAll_false S3; case M; search.
			W: case W. inFV: applys inFV_subst W2 with A = A1, m = m. search.
	A: assert append (styvar n2 :: F n1) (tyvar n1 :: E) (styvar n2 :: FxE n1).
		S: applys IH A2.
		W: applys sub_wft S. W: case W. W: case W1.
		FV: applys inFV_subst W2 with A = A1, m = m.
		FV: applys inFV_subst W3 with A = B1, m = m.
		search.


Theorem wft_open_free : forall E (A : ty -> ty -> ty) m Ar, nabla x,
	wft (E x) (A x (m x)) -> mono (E x) (m x) ->
		A x (m x) = Ar -> exists A', A = x\ m\ A' m.
induction on 1. intros. Aux: assert forall (A : ty) B, A = B -> B = A. case H1.
	case H4. search. search.
	case H4. search. search.
	case H4. search. search.
	case H4. search. search.
	case H4. case H3. search.
	case H4. search. search.
	case H4. case H3. search.
	case H4. Eq: case H3.
		Eq: apply Aux to Eq. Eq: apply Aux to Eq1.
			apply IH to H5 _ _ with A = A2.
			apply IH to H6 _ _ with A = A3.
			search.
		search.
	case H4. Eq: case H3.
		Eq: apply Aux to Eq.
			Aux: assert forall (A : ty -> ty) B, nabla x, A = B -> A x = B x.
			Eq: apply Aux1 to Eq1.
			apply IH to H5 _ Eq2 with A = x\ m\ A2 x m n2, x = n1.
				backchain mono_weaken_ty. search.
		search.

Theorem typeSubst :
	(forall F E FE FxE m X C, nabla x,
		append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
		mono E m -> chk (FxE x) (X x) (C x) -> chk (FE m) (X m) (C m)) /\
	(forall F E FE FxE m X C, nabla x,
		append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
		mono E m -> inf (FxE x) (X x) (C x) -> inf (FE m) (X m) (C m)) /\
	(forall F E FE FxE m X B C, nabla x,
		append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
		mono E m -> infApp (FxE x) (B x) (X x) (C x) -> infApp (FE m) (B m) (X m) (C m)).
induction on 4 4 4. split.
	intros. D: case H4.
		W: applys mono_wfta.
			W: applys wftm_strenthen_tyvar_notfresh H1.
			search.
		A: assert append (tyvar n2 :: F n1) E (tyvar n2 :: FE n1).
			D: apply IH to A _ _ D with x = n1.
			W: applys mono_wft H3.
			applys wft_strenthen_tyvar_notfresh H1 H2 D1 W.
			search.
		A: assert append (of n2 (A n1) :: F n1) E (of n2 (A n1) :: FE n1).
			W: apply wft_wfta to D.
			D: apply IH to A _ _ D1 with x = n1.
			W: apply mono_wft to H3.
			W: apply wft_strenthen_tyvar_notfresh to H1 H2 D _. search.
		D: apply IH1 to _ _ _ D1.
			S: applys sub_substM D2.
			All: assert notAll_ (C m).
				W: applys sub_wft D2. W: case W1; try search; try applys notAll_false D.
					M: case H3; search.
					M: case H3; search.
			search.
	intros. D: case H4.
		apply mono_prune_tm to H3.
			M: apply member_of_subst to D with A = x\ y\ m x.
			A: apply append_subst to H1 with A = m1.
			M: assert member (of n2 (A1 m1)) (FE n2 m1).
				A: apply append_subst to H2 with A = m1.
				M: apply append_mem_inv to A1 _. M: case M1.
				backchain append_mem. M: case M1. backchain append_mem.
			search.
		D: apply IH to _ _ _ D. search.
		applys IH.
			W: applys mono_wft H3.
			applys wft_strenthen_tyvar_notfresh D W.
			search.
		search.
		W: apply mono_wfta to D. W: case W.
			D: apply IH to _ _ _ D1.
			M: apply mono_strenthen_tyvar_notfresh to _ _ D H3. search.
		D: apply IH1 to _ _ _ D.
			D: apply IH2 to _ _ _ D1. search.
		D: applys IH1.
			W: applys mono_wft H3.
			W: applys wft_strenthen_tyvar_notfresh D W.
			search.
		D: applys IH1.
			W: applys mono_wft H3.
			W: applys wft_strenthen_tyvar_notfresh D W.
			search.
	intros. D: case H4.
		D: apply IH2 to _ _ _ D.
			M: apply mono_strenthen_tyvar_notfresh to _ _ D1 H3.
			W: applys mono_wft H3.
			applys wft_strenthen_tyvar_notfresh. search.
		D: apply IH to _ _ _ D.
			W: apply mono_wft to H3.
			W: apply wft_strenthen_tyvar_notfresh to _ _ D1 W. search.
		W: applys mono_wfta H3.
			applys wftm_strenthen_tyvar_notfresh.
			search.

Split typeSubst as typeSubst_chk, typeSubst_inf, typeSubst_infApp.


% ex_free + wfj -> wfta -> wft
Define esub : olist -> olist -> prop by
	esub nil nil;
	esub (j J :: E) (j J :: F) := esub E F;
	nabla x, esub (tyvar x :: E) (tyvar x :: F) := esub E F;
	nabla x, esub (styvar x :: E) (styvar x :: F) := esub E F;
	nabla t, esub (of t A0 :: E) (of t A :: F) := sub F A0 A /\ esub E F.

Theorem wfj_exFree_wfta_wft : forall E A, wfj E -> exFree E -> wfta E A -> wft E A.
induction on 3. intros. case H3; try search.
	apply exFree_false to _ H2.
	apply IH to _ _ H4. apply IH to _ _ H5. search.
	apply IH to _ _ H4. backchain exFree_tyvar. search.

Theorem esub_eq : forall E, wfj E -> exFree E -> esub E E.
induction on 1. intros. W: case H1. search.
	F: apply exFree_weaken to H2. J: apply IH to W _. search.
	F: apply exFree_weaken to H2. J: apply IH to W _. search.
	apply exFree_false to _ H2.
	F: apply exFree_weaken to H2. W: apply wfj_exFree_wfta_wft to _ _ W1.
		D: apply sub_refl to _. J: apply IH to W _. search.
	F: apply exFree_weaken to H2. J: apply IH to W _. search.

Theorem esub_tyvar : forall E F, nabla x,
	esub (E x) (F x) -> member (tyvar x) (E x) -> member (tyvar x) (F x).
induction on 1. intros. case H1. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H4 _. search.

Theorem esub_styvar : forall E F, nabla x,
	esub (E x) (F x) -> member (styvar x) (E x) -> member (styvar x) (F x).
induction on 1. intros. case H1. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	search.
	case H2. apply IH to H4 _. search.

Theorem esub_mono : forall E F m, esub E F -> mono E m -> mono F m.
induction on 2. intros. case H2. search.
	apply esub_tyvar to H1 _. search.
	apply IH to _ H3. apply IH to _ H4. search.

Theorem esub_wft : forall E F m, esub E F -> wft E m -> wft F m.
induction on 2. intros. case H2; try search.
	apply esub_tyvar to H1 _. search.
	apply esub_styvar to H1 _. search.
	apply IH to _ H3. apply IH to _ H4. search.
	apply IH to _ H3. search.

Theorem esub_pruneF : forall E F, nabla (x : ty),
	esub E (F x) -> exists Fr, F = x\ Fr.
induction on 1. intros. case H1; try applys IH; try search.
	applys sub_wft H2. applys wft_prune H5. search.

Theorem esub_pruneE : forall E F, nabla (x : ty),
	esub (E x) F -> exists Er, E = x\ Er.
induction on 1. intros. case H1; try applys IH; try search.
	applys sub_wft H2. applys wft_prune H4. search.

% Theorem esub_subT : forall E F T TE TF,
% 	esub E F -> subT E T \/ subT F T -> append T E TE -> append T F TF -> esub TE TF.
% induction on 3. intros. case H3; case H4.
% 	search.
% 	ST: case H2; ST: case ST.
% 		applys esub_pruneF.
% 			applys append_prune_AB H5. applys append_prune_AB H6.
% 			applys IH H6. search.
% 		applys esub_pruneE.
% 			applys append_prune_AB H5. applys append_prune_AB H6.
% 			applys IH H6. search.

Theorem esub_sub : forall E F A B,
	esub E F -> sub E A B -> sub F A B.
induction on 2. intros. case H2. search.
	applys esub_wft H3. search.
	applys esub_wft H3. search.
	apply esub_tyvar to H1 _. search.
	applys esub_styvar H1. search.
	applys IH H3. applys IH H4. search.
	applys IH. applys esub_mono H1. search.
	applys IH. search.

Theorem esub_tyvar_inv : forall E F, nabla x,
	esub (F x) (E x) -> member (tyvar x) (E x) -> member (tyvar x) (F x).
induction on 1. intros. case H1; try solve (case H2; try applys IH; search).
Theorem esub_styvar_inv : forall E F, nabla x,
	esub (F x) (E x) -> member (styvar x) (E x) -> member (styvar x) (F x).
induction on 1. intros. case H1; try solve (case H2; try applys IH; search).

Theorem esub_mono_inv : forall E F m, esub F E -> mono E m -> mono F m.
induction on 2. intros. case H2. search.
	apply esub_tyvar_inv to H1 _. search.
	apply IH to _ H3. apply IH to _ H4. search.

Theorem esub_wft_inv : forall E F m, esub F E -> wft E m -> wft F m.
induction on 2. intros. case H2. search.
	search. search.
	apply esub_tyvar_inv to H1 _. search.
	apply esub_styvar_inv to H1 _. search.
	apply IH to _ H3. apply IH to _ H4. search.
	apply IH to _ H3. search.

Theorem esub_sub_inv : forall E F A B,
	esub F E -> sub E A B -> sub F A B.
induction on 2. intros. case H2. search.
	W: applys esub_wft_inv H3. search.
	W: applys esub_wft_inv H3. search.
	apply esub_tyvar_inv to H1 _. search.
	apply esub_styvar_inv to H1 _. search.
	applys IH H3. applys IH H4. search.
	applys IH. applys esub_mono_inv H1. search.
	applys IH. search.

Theorem esub_of : forall E F A, nabla t,
	esub (E t) (F t) -> member (of t A) (E t) ->
	exists A0, nabla t, member (of t A0) (F t) /\ sub (F t) A A0.
induction on 1. intros. case H1.
	case H2.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: applys sub_weaken_f H6 with EF = j (J n1) :: F1 n1. search.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: applys sub_weaken_ty H6. search.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: applys sub_weaken_sty H6. search.
	case H2. apply IH to H4 _.
		apply member_prune_tm to H5. apply member_prune_tm to H6.
		W: apply sub_wft to H3. W: apply esub_wft_inv to H4 _.
		D: applys sub_weaken_of H7 with X = A1 n1. search.
	case H2.
		W: apply sub_wft to H3. D: applys sub_weaken_of H3 with X = A1. search.
		apply member_prune_tm to H5.

Theorem esub_of_inv : forall E F A, nabla t,
	esub (F t) (E t) -> member (of t A) (E t) ->
	exists A0, nabla t, member (of t A0) (F t) /\ sub (F t) A0 A.
induction on 1. intros. case H1.
	case H2.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: applys sub_weaken_f H6 with EF = j (J n1) :: E1 n1. search.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: applys sub_weaken_ty H6. search.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: applys sub_weaken_sty H6. search.
	case H2. apply IH to H4 _.
		apply member_prune_tm to H5. apply member_prune_tm to H6.
		W: apply sub_wft to H3. W: apply esub_wft_inv to H4 _.
		D: applys sub_weaken_of H7 with X = A0 n1. search.
	case H2.
		W: apply sub_wft to H3. D: applys sub_weaken_of H3 with X = A1.
		D: applys esub_sub_inv D. search.
		apply member_prune_tm to H5.

Theorem esub_exFree : forall E F, esub E F -> exFree E /\ exFree F.
induction on 1. intros. case H1.
	applys exFree_nil. search.
	applys IH. split. backchain exFree_j. backchain exFree_j.
	applys IH. split. backchain exFree_tyvar. backchain exFree_tyvar.
	applys IH. split. backchain exFree_styvar. backchain exFree_styvar.
	applys IH. split. backchain exFree_of. backchain exFree_of.

Theorem esub_wfta_wft : forall E F A, esub E F -> wfta E A -> wft E A.
intros E W.
	Ex: applys esub_exFree.
	applys exFree_wfta_wft. search.

Theorem esub_wfta_wft_F : forall E F A, esub E F -> wfta F A -> wft F A.
intros E W.
	Ex: applys esub_exFree.
	applys exFree_wfta_wft. search.

Theorem esub_wftm_inv : forall E F X, esub E F -> wftm F X -> wftm E X.
induction on 2. intros. case H2. search.
	apply esub_of_inv to H1 _. search.
	W: applys esub_wfta_wft_F.
		S: applys sub_refl W.
		W: applys esub_wft_inv. W: applys wft_wfta W1.
		applys IH. search.
	applys IH.
	apply IH to _ H3. apply IH to _ H4. search.
	apply IH to _ H3.
		W: applys esub_wfta_wft_F.
		W: applys esub_wft_inv. W: applys wft_wfta W1.
		search.
	applys IH.
		W: applys esub_wfta_wft_F.
		W: applys esub_wft_inv. W: applys wft_wfta W1.
		search.
	applys IH.
		W: applys esub_wfta_wft_F H4.
		W: applys esub_wft_inv W. W: applys wft_wfta W1.
		search.

Define tyExt : olist -> olist -> olist -> olist -> prop by
	tyExt E E F F;
	nabla x, tyExt E (tyvar x :: Ex) F (tyvar x :: Fx) := tyExt E Ex F Fx.

Theorem tyExt_esub : forall E F Ex Fx, tyExt E Ex F Fx -> esub E F -> esub Ex Fx.
induction on 1. intros. case H1. search.
	apply IH to H3 _. search.

Theorem tyExt_env : forall E F Ex Fx, tyExt E Ex F Fx -> env E -> env F -> env Ex /\ env Fx.
induction on 1. intros. case H1. search.
	apply IH to H4 _ _. search.


Define tmSize : tm -> nat -> prop by
	tmSize unit (s z);
	nabla x, tmSize x (s z);
	tmSize (lam X) (s N) := nabla x, tmSize (X x) N;
	tmSize (app X Y) (s K) := exists M N, tmSize X M /\ tmSize Y N /\ add M N K;
	tmSize (anno X A) (s N) := tmSize X N;
	tmSize (tApp X A) (s N) := tmSize X N;
	tmSize (tAnno X A) (s N) := nabla x, tmSize (X x) N.

Theorem tmSize_prune : forall X N, nabla (x : ty),
	tmSize (X x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search. search.
	apply IH to H2. search.
	apply IH to H2. apply IH to H3. apply add_prune_k[ty] to H4. search.
	apply IH to H2 with x = n1. search.
	apply IH to H2 with x = n1. search.
	apply IH to H2 with x = n1. search.

Theorem tmSize_prune_tm : forall X N, nabla (x : tm),
	tmSize (X x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search. search. search.
	apply IH to H2 with x = n1. search.
	apply IH to H2. apply IH to H3. apply add_prune_k[tm] to H4. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem tmSize_subst : forall X A N, nabla (x : ty),
	tmSize (X x) N -> tmSize (X (A x)) N.
induction on 1. intros. case H1. search. search.
	apply IH to H2 with A = A. search.
	apply tmSize_prune to H2. apply IH to H2 with A = A.
		apply tmSize_prune to H3. apply IH to H3 with A = A. search.
	apply IH to H2 with A = A. search.
	apply IH to H2 with A = A. search.
	apply IH to H2 with A = A. search.

Theorem tmSize_det : forall X N1 N2, tmSize X N1 -> tmSize X N2 -> N1 = N2.
induction on 1. intros. case H1.
	case H2. search. case H2. search.
	case H2. apply IH to H3 H4. search.
	case H2. apply IH to H3 H6. apply IH to H4 H7. apply add_det to H5 H8. search.
	case H2. apply IH to H3 H4. search.
	case H2. apply IH to H3 H4. search.
	case H2. apply IH to H3 H4. search.

Theorem tmSize_is_nat : forall X N, tmSize X N -> is_nat N.
induction on 1. intros. case H1. search. search.
	apply IH to H2. search.
	apply IH to H3. apply add_is_nat_k to H5 H4. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem tmSize_total : forall E X, wftm E X -> exists N, tmSize X N.
induction on 1. intros. case H1. search. search.
	apply IH to H3. apply tmSize_prune_tm to H4. search.
	apply IH to H2. apply IH to H3. apply tmSize_is_nat to H4.
		apply add_total to H6 with n = N1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. applys tmSize_prune H4. search.

Theorem lt_sm : forall m n, lt (s m) n -> exists N, n = s N /\ lt m N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.

Theorem tmSize_s : forall X N, tmSize X N -> exists n, N = s n.
intros. case H1; search.

Theorem order_total_wft_thm : forall E A, wft E A -> exists N, order A N.
induction on 1. intros. case H1; try search.
	apply IH to H2. apply IH to H3. apply order_is_nat to H4.
		apply add_total to H6 with n = N1. search.
	apply IH to H2. apply order_prune to H4. search.

Theorem order_total_wft_N : forall E A, wft E A -> exists N, order A N /\ is_nat N.
intros. apply order_total_wft_thm to H1. apply order_is_nat to H2. search.

%%%%%%%%%%%%%%%%%%%% Typing Properties %%%%%%%%%%%%%%%%%%%%
Theorem chkInfApp_weaken :
	(forall E F G EG EFG X A, 
		append E G EG -> split3 E F G EFG -> chk EG X A -> chk EFG X A) /\
	(forall E F G EG EFG X A,
		append E G EG -> split3 E F G EFG -> inf EG X A -> inf EFG X A) /\
	(forall E F G EG EFG X A C,
		append E G EG -> split3 E F G EFG -> infApp EG A X C -> infApp EFG A X C).
induction on 3 3 3. split.
	intros. case H3.
		W: applys wftm_weaken H2. search.
		S: apply split3_cons to H2 with X = tyvar n1.
			D: apply IH to _ S H4. W: applys wft_weaken. search.
		S: apply split3_cons to H2 with X = of n1 A1.
			W: apply wft_weaken to H1 H2 H4.
			D: apply IH to _ S H5. search.
		S: apply IH1 to _ _ H5.
			D: applys sub_weaken H1 H2 H6. search.
	intros. case H3.
		M: assert member (of n1 A1) (EFG n1).
			M: apply append_mem_inv to _ H4. M: case M.
			backchain split3_mem. backchain split3_mem.
			search.
		apply IH to _ _ H4. search.
		S: applys split3_cons H2 with X = tyvar n1.
			applys IH S.
			W: applys wft_weaken.
			search.
		search.
		S: apply split3_cons to H2 with X = of n1 M1.
			M: apply mono_weaken to H1 H2 _.
			W: apply mono_wft to M. W: case W.
			D: apply IH to _ S H5. search.
		D: apply IH1 to _ _ H4.
			D: apply IH2 to _ _ H5. search.
		D: applys IH1. applys wft_weaken. search.
		D: applys IH1. applys wft_weaken. search.
	intros. case H3.
		M: apply mono_weaken to H1 H2 _.
			D: apply IH2 to _ _ H4.
			applys wft_weaken. search.
		W: apply wft_weaken to H1 H2 H5.
			D: apply IH to _ _ H4. search.
		W: applys wftm_weaken. search.

Split chkInfApp_weaken as chk_weaken, inf_weaken, infApp_weaken.

Theorem chk_weaken_f : forall F E FE X A,
	chk E X A -> append F E FE -> chk FE X A.
intros. T: apply chk_weaken to _ _ H1. search.
Theorem chk_weaken_ex : forall E X A, nabla x,
	chk E X A -> chk (exvar x :: E) X A.
intros. backchain chk_weaken_f with F = exvar n1 :: nil.
Theorem chk_weaken_ty : forall E X A, nabla x,
	chk E X A -> chk (tyvar x :: E) X A.
intros. backchain chk_weaken_f with F = tyvar n1 :: nil.
Theorem chk_weaken_sty : forall E X A, nabla x,
	chk E X A -> chk (styvar x :: E) X A.
intros. backchain chk_weaken_f with F = styvar n1 :: nil.
Theorem chk_weaken_of : forall E X A T, nabla x,
	chk E X A -> chk (of x T :: E) X A.
intros. backchain chk_weaken_f with F = of n1 T :: nil.

Theorem inf_weaken_f : forall F E FE X A,
	inf E X A -> append F E FE -> inf FE X A.
intros. T: apply inf_weaken to _ _ H1. search.
Theorem inf_weaken_ex : forall E X A, nabla x,
	inf E X A -> inf (exvar x :: E) X A.
intros. backchain inf_weaken_f with F = exvar n1 :: nil.
Theorem inf_weaken_ty : forall E X A, nabla x,
	inf E X A -> inf (tyvar x :: E) X A.
intros. backchain inf_weaken_f with F = tyvar n1 :: nil.
Theorem inf_weaken_sty : forall E X A, nabla x,
	inf E X A -> inf (styvar x :: E) X A.
intros. backchain inf_weaken_f with F = styvar n1 :: nil.
Theorem inf_weaken_of : forall E X A T, nabla x,
	inf E X A -> inf (of x T :: E) X A.
intros. backchain inf_weaken_f with F = of n1 T :: nil.

Theorem infApp_weaken_f : forall F E FE A X C,
	infApp E A X C -> append F E FE -> infApp FE A X C.
intros. T: apply infApp_weaken to _ _ H1. search.
Theorem infApp_weaken_ex : forall E A X C, nabla x,
	infApp E A X C -> infApp (exvar x :: E) A X C.
intros. backchain infApp_weaken_f with F = exvar n1 :: nil.
Theorem infApp_weaken_ty : forall E A X C, nabla x,
	infApp E A X C -> infApp (tyvar x :: E) A X C.
intros. backchain infApp_weaken_f with F = tyvar n1 :: nil.
Theorem infApp_weaken_sty : forall E A X C, nabla x,
	infApp E A X C -> infApp (styvar x :: E) A X C.
intros. backchain infApp_weaken_f with F = styvar n1 :: nil.
Theorem infApp_weaken_of : forall E A X C T, nabla x,
	infApp E A X C -> infApp (of x T :: E) A X C.
intros. backchain infApp_weaken_f with F = of n1 T :: nil.


Theorem wft_strenthen_of : forall F E FE FxE A T, nabla x,
	append F E FE -> append F (of x T :: E) (FxE x) ->
	wft (FxE x) A -> wft FE A.
induction on 3. intros. W: case H3. search.
	search. search.
	M: apply append_mem_inv to _ W. M: case M.
		apply append_mem to H1 _. search. M: case M. apply append_mem to H1 _. search.
	M: apply append_mem_inv to _ W. M: case M.
		apply append_mem to H1 _. search. M: case M. apply append_mem to H1 _. search.
	W: apply IH to H1 H2 W. W: apply IH to H1 H2 W1. search.
	W: apply IH to _ _ W with F = tyvar n2 :: F, FE = tyvar n2 :: FE. search.

Theorem wft_remove_of : forall E A T, nabla x,
	wft (of x T :: E) A -> wft E A.
intros. apply wft_strenthen_of to _ _ H1 with FE = E. search.


Theorem wfj_of_wfta : forall E A, nabla x,
	wfj (E x) -> member (of x A) (E x) -> wfta (E x) A.
induction on 2. intros. case H2.
	case H1. backchain wfta_weaken_of.
	assert append (B n1 :: nil) (L n1) (B n1 :: L n1).
		apply wfj_rev to H1. apply IH to _ H3.
		backchain wfta_weaken_f.

Theorem exFree_of_wft : forall E A, nabla x,
	wfj (E x) -> exFree (E x) -> member (of x A) (E x) -> wft (E x) A.
intros. apply wfj_of_wfta to H1 H3.
	backchain wfj_exFree_wfta_wft.

Theorem wfj_of_det : forall E A A1, nabla x,
	wfj (E x) -> member (of x A) (E x) -> member (of x A1) (E x) -> A = A1.
induction on 1. intros. case H1. case H2.
	case H2. case H3. apply IH to H4 H5 H6. search.
	case H2. case H3. apply IH to H4 H5 H6. search.
	case H2. case H3. apply IH to H4 H5 H6. search.
	case H2. case H3. apply IH to H4 H7 H6. search.
	case H2. case H3. search. apply member_prune_tm to H6. apply member_prune_tm to H6.
	case H2. case H3. apply IH to H4 H6 H7. search.

Theorem chkInfApp_wft :
	(forall E X A, chk E X A -> wfj E -> exFree E -> wft E A) /\
	(forall E X A, inf E X A -> wfj E -> exFree E -> wft E A) /\
	(forall E X A C, infApp E A X C -> wfj E -> exFree E -> wft E A /\ wft E C).
induction on 1 1 1. split.
	intros. case H1 (keep). search. search.
		W: apply wft_wfta to H4. apply IH to H5 _ _. backchain exFree_of.
			W: apply wft_remove_of to H6. search.
		apply sub_wft to H6. search.
	intros. case H1 (keep).
		backchain exFree_of_wft.
		apply IH to H4 _ _. search.
		applys IH. backchain exFree_tyvar. search.
		search.
		W: apply mono_wft to H4. search.
		apply IH2 to H5 _ _. search.
		applys IH1. search.
		applys IH1. W: applys wft_open_a H6 H4. search.
	intros. case H1.
		apply IH2 to H4 _ _.
			W: apply wft_weaken_f to _ H6 with EF = tyvar n1 :: E.
			search.
			% W: apply wft_subst to W _ with T = A1, m = n1. search.
		apply IH to H4 _ _. search.
		search.

Split chkInfApp_wft as chk_wft, inf_wft, infApp_wft.

Theorem chkInfApp_wftm :
	(forall E X A, chk E X A -> wfj E -> exFree E -> wftm E X) /\
	(forall E X A, inf E X A -> wfj E -> exFree E -> wftm E X) /\
	(forall E X A C, infApp E A X C -> wfj E -> exFree E -> wftm E X).
induction on 1 1 1. split.
	intros. case H1. search.
		apply IH to H4 _ _. backchain exFree_tyvar.
			applys wftm_strenthen_tyvar H6. search.
		W: apply wft_wfta to H4. apply IH to H5 _ _. backchain exFree_of.
			search.
		applys IH1. search.
	intros. case H1.
		search.
		applys IH.
			Ts: applys chkInfApp_wft.
			W: applys Ts. W: applys wft_wfta W.
			search.
		applys IH. backchain exFree_tyvar.
			W: case H4. W: applys wft_wfta W.
			search.
		search.
		M: case H4. W: applys mono_wfta M.
			applys IH. backchain exFree_of.
			search.
		W: applys IH1. W: applys IH2. search.
		W: applys IH1. W: applys wft_wfta H4. search.
		W: applys IH1. W: applys wft_wfta H4. search.
	intros. case H1.
		applys IH2. search.
		applys IH H4. search.
		search.

Split chkInfApp_wftm as chk_wftm, inf_wftm, infApp_wftm.



Define subSize : olist -> ty -> ty -> nat -> prop by	
	subSize E i i z;
	subSize E A top z := wft E A;
	subSize E bot A z := wft E A;
	nabla x, subSize (E x) x x z := nabla x, member (tyvar x) (E x);
	nabla x, subSize (E x) x x z := nabla x, member (styvar x) (E x);
	subSize E (arrow A1 A2) (arrow B1 B2) (s K) := exists M N,
		subSize E B1 A1 M /\ subSize E A2 B2 N /\ add M N K;
	subSize E (all A) B (s N) :=
			exists m, subSize E (A m) B N /\ mono E m /\ notAll_ B /\ inFV A;
	subSize E (all A) (all B) (s N) :=
			nabla x, subSize (styvar x :: E) (A x) (B x) N /\ inFV A /\ inFV B.

Theorem subSize_sub : forall E A B N, subSize E A B N -> sub E A B.
induction on 1. intros. case H1; try search.
	apply IH to H2. apply IH to H3. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem subSize_is_nat : forall E A B N, subSize E A B N -> is_nat N.
induction on 1. intros. case H1; try search.
	apply IH to H3. apply add_is_nat_k to _ H4. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem subSize_prune : forall E A B N, nabla (x : ty),
	subSize (E x) (A x) (B x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1; try search.
	apply IH to H2. apply IH to H3. apply add_prune_k to H4. search.
	apply IH to H2. search.
	apply IH to H2 with x = n1. search.

Theorem subSize_total : forall E A B, sub E A B -> exists N, subSize E A B N.
induction on 1. intros. case H1; try search.
	apply IH to H2. apply IH to H3.
		N: apply subSize_is_nat to H4. apply add_total to N with n = N1. search.
	apply IH to H2. search.
	apply IH to H2. apply subSize_prune to H5. search.

Theorem subSize_weaken : forall E F G T1 T2 EG EFG N,
	append E G EG -> split3 E F G EFG ->
	subSize EG T1 T2 N -> subSize EFG T1 T2 N.
induction on 3. intros. case H3.
	search.
	applys wft_weaken. search.
	applys wft_weaken. search.
	applys mem_GE_GFE H4. search.
	applys mem_GE_GFE H4. search.
	applys IH H4. applys IH H5. search.
	applys IH H4. applys mono_weaken H5. search.
	S: applys split3_cons H2 with X = styvar n1.
		applys IH S. search.
Theorem subSize_weaken_f : forall E F EF T1 T2 N,
	append E F EF -> subSize F T1 T2 N -> subSize EF T1 T2 N.
intros. backchain subSize_weaken with E = nil, F = E, G = F.
Theorem subSize_weaken_fx : forall E X T1 T2 N,
	subSize E T1 T2 N -> subSize (X :: E) T1 T2 N.
intros. backchain subSize_weaken_f with E = X :: nil, F = E.


Theorem wft_higher_order_prune : forall (A : ty -> ty -> ty) m1 m2 E Ar, nabla x,
			wft E (A m1 m2) -> A x m2 = Ar -> exists Ar', A = x\ Ar'.
Aux: assert forall A (B : ty), A = B -> B = A.
induction on 1. intros W Eq. W: case W.
	case W (keep); case Eq; search.
	case W (keep); case Eq; search.
	case W (keep); case Eq; search.
	case W (keep); case Eq; search.
	case W (keep); case Eq; search.
	case W (keep); Eq: case Eq; try search.
		Eq: apply Aux to Eq. Eq: apply Aux to Eq1.
		applys IH W1 with A = A2. applys IH W2 with A = A3.
		search.
	case W (keep); Eq: case Eq; try search.
		Eq: apply Aux to Eq. % abella fail: applys IH W1 with A = x\ y\ A4 x y n1.
		Aux: assert forall A (B : ty -> ty), nabla x, A = B -> A x = B x.
		Eq: apply Aux1 to Eq1. permute (n1 n2) Eq2.
		apply IH to W1 Eq2 with A = x\ y\ A2 x y n1, x = n2.
		search.

Theorem sub_inst_bot : forall E A m,
	sub E (A m) bot -> mono E m -> exists Ar, A = x\ Ar.
induction on 1. intros S M. W: applys sub_wft S. S: case S.
	case S. search. case M.
	case S; try solve case M.
	Eq: applys IH with A = x\ A2 x m1.
		Aux: assert forall A (B : ty -> ty), nabla x, A = B -> A x = B x.
		Eq: apply Aux to Eq.
		W: applys sub_wft S1.
		applys wft_higher_order_prune W2 with A = A2.
		search.

Theorem inFV_false : forall A, inFV x\ A -> false.
intros. case H1. applys H2.

Theorem sub_all_bot_false : forall E A, sub E (all A) bot -> false.
induction on 1. intros. case H1.
	applys sub_inst_bot H2 with A = A.
	case H5. applys H6.

Theorem sub_trans_thm : forall E A B C n N S1 S2 ns Ns,
	order B n -> lt n N -> is_nat N ->
	subSize E A B S1 -> subSize E B C S2 ->
	add S1 S2 ns -> lt ns Ns -> is_nat Ns ->
	wfj E -> sub E A C.
induction on 3. induction on 8. intros.
	D: apply subSize_sub to H5.
	D: case H4 (keep); try search.
		D: case D. search.
			% N: case H5. case H6. L: applys lt_sm H7.
			% N: case H8.
			% S: applys subSize_weaken_fx H4 with X = tyvar n1.
			% applys IH1 S N. search.
		W: applys sub_wft D. search.
		% A1 -> A2 <: B1 -> B2
		clear D. N: apply subSize_is_nat to H5. D: case H5.
			% top
			S: applys subSize_sub D1. S: applys subSize_sub D2.
				W: applys sub_wft S. W: applys sub_wft S1.
				search.
			% A1 -> A2 <: B1 -> B2 <: B3 -> B4
			P: case H6. P: apply add_s_inv to *P.
				P: apply add_assoc4 to D3 D5 _.
				L: apply lt_sm to *H7. L: apply lt_sm to *L.
				IS: case H8. IS: case IS.
				N: case N. N: apply add_is_nat_k to _ P.
				L: apply add_le to _ P3.
				L: apply le_trans to _ L1 _. L: apply le_trans to _ L2 _.
				N: apply order_is_nat to H1. O: case H1. L: apply add_le to _ O2.
				L: apply le_trans to _ L5 _. L: apply le_trans to _ L6 _.
				D: apply IH1 to _ L7 H3 _ _ P1 _ IS _.
				D: apply IH1 to _ L8 H3 _ _ P2 _ IS _.
				search.
			% A1 -> A2 <: B1 -> B2 <: \forall a. B3
			% D: apply subSize_weaken_f to _ H4 with EF = tyvar n1 :: E.
			% 	P: apply add_s_inv to *H6.
			% 	L: apply lt_sm to H7. IS: case H8.
			% 	D: apply IH1 to _ H2 H3 D4 D P _ IS. search.
	% \forall x. A <: B
	P: case H6. L: apply lt_sm to *H7.
		IS: case H8.
		D: apply IH1 to _ _ H3 _ _ P _ IS _.
		D: case D (keep); try search; try applys notAll_false.
		D: applys subSize_sub D1.
		Gen: assert forall E A C N, order A N -> is_nat N ->
				sub E A bot -> wft E C -> sub E A C.
			induction on 2. intros O N S W. W: applys sub_wft S. S: case S (keep).
				search.
				O: case O. N: case N.
				O: applys order_subst O _ S2 with A = A3.
					S: applys IH2 S1.
					W: case W1.
					W: case W (keep); try search.
					applys sub_inst_bot S1 with A = A3.
					applys inFV_false W3.
		S: applys subSize_sub H4.
			W: applys sub_wft S.
			O: applys order_total_wft W.
			N: applys order_is_nat O.
		backchain Gen.
	% A <: \forall x. B
	D: case H5.
		% top
		S: applys subSize_sub H4. W: applys sub_wft S. search.
		% A <: \forall x. B <: C
		D: apply subSize_sub to D1.
			W: applys mono_wft D5.
			W: applys wft_weaken_f W with E = styvar n1 :: nil.
			D: applys sub_subst_wft W1 D8.
			D: apply subSize_total to D9. applys subSize_prune D10.
			N: apply subSize_is_nat to D10. P: apply add_total to N with n = N2.
			N: apply add_is_nat_k to _ P. backchain subSize_is_nat.
			O: case H1. O: apply order_subst to _ D5 O with A = B1.
			L: apply lt_sm to *H2. IO: case H3.
			D: applys subSize_weaken_f D4 with E = styvar n1 :: nil.
			D: apply IH to _ _ IO D10 D11 P _ _ _ with Ns = s k.
			D: applys sub_strenthen_styvar_f D12.
			search.
		% A <: \forall x. B <: \forall x. C
		P: applys add_s_inv *H6. P: case P.
			lt: applys lt_sm *H7. lt: applys lt_sm *lt.
			O: case H1. lt: applys lt_sm *H2. IN: case H3.
			N: case H8.
			applys IH D1 D4 P N. search.
		% D: apply subSize_weaken_f to _ H4 with EF = tyvar n1 :: E.
		% 	P: apply add_s_inv to *H6.
		% 	L: apply lt_sm to H7. IS: case H8.
		% 	D: apply IH1 to _ H2 H3 D3 D2 P _ IS. search.

Theorem sub_trans : forall E A B C,
	sub E A B -> sub E B C -> wfj E -> sub E A C.
intros. D: apply subSize_total to H1. D: apply subSize_total to H2.
	W: applys sub_wft H1.
	O: apply order_total_wft_N to W1.
	N: apply subSize_is_nat to D. N: apply subSize_is_nat to D1.
	P: apply add_total to N with n = N1. N: apply add_is_nat_k to _ P.
	D: apply sub_trans_thm to O _ _ D D1 _ _ _ _ with N = s N2, Ns = s k.
	search.

% Theorem sub_allR_inv : forall E A B, nabla x,
% 	sub E A (all B) -> sub (tyvar x :: E) A (B x).
% induction on 1. intros. case H1.
% 	W: case H2. search.
% 	apply IH to H2. M: apply mono_weaken_ty to H3. search.
% 	search.

Theorem mono_sty_ty : forall F E FtyE FstyE M, nabla x,
	append (F x) (tyvar x :: E) (FtyE x) -> append (F x) (styvar x :: E) (FstyE x) ->
	mono (FstyE x) M -> mono (FtyE x) M.
induction on 3. intros. case H3. search.
	applys mem_FxE_FyE H2. search.
	applys IH H4. applys IH H5. search.

Theorem sub_sty_ty : forall F E FtyE FstyE A B, nabla x,
	append (F x) (tyvar x :: E) (FtyE x) -> append (F x) (styvar x :: E) (FstyE x) ->
	sub (FstyE x) (A x) (B x) -> wfj (FstyE x) -> sub (FtyE x) (A x) (B x).
induction on 3. intros A A S. S: case S.
	search.
	applys wft_sty_ty S. search.
	applys wft_sty_ty S. search.
	applys mem_FxE_FyE A1. search.
	applys mem_FxE_FyE A1. search.
	applys mem_FxE_FyE A1. search.
	applys mem_FxE_FyE A1. search.
	applys IH S. applys IH S1. search.
	S: applys IH S.
		applys mono_prune_styvar. backchain append_mem.
		M: applys mono_sty_ty A A1.
		search.
	S: applys IH. search.


Theorem subsumption_thm :
	(forall E' E X Nx NX NO A A',
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat (s z) ->
			order (arrow A A') NO -> is_nat NO ->
		esub E' E -> chk E X A ->
		sub E A A' -> wfj E -> exFree E ->
		chk E' X A') /\
	(forall E' E X Nx NX A,
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat z ->
		esub E' E -> inf E X A -> wfj E -> exFree E ->
		exists A', sub E A' A /\ inf E' X A') /\
	(forall E' E X Nx NX NO A C C',
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat (s (s z)) ->
			order (arrow C C') NO -> is_nat NO ->
		esub E' E -> infApp E C X A ->
		sub E C' C -> wfj E -> exFree E ->
		exists A', sub E A' A /\ infApp E' C' X A').
induction on 2 2 2. IJ: induction on 4 4 4. clear IJ2. split.
	IO: induction on 6. intros. case H8.
		% e <== top
		S: case H9.
			% top <: top
				applys esub_wftm_inv.
				search.
			% top <: \forall b. B
				% O: case H5. O: case O1. case O. case O2.
				% IO: case H6.
				% D: applys IO H2 H4 IO1 S with X = X.
				% 	backchain exFree_tyvar.
				% 		applys wftm_weaken_ty H12. search.
				% 	search.
		% e <== \forall a. A1
		D: case H9.
			% top
				Ex: applys exFree_tyvar H11.
				W: applys chk_wftm H12. W: applys wftm_strenthen_tyvar_notfresh W.
				case D.
				W: applys esub_wftm_inv. search.
			% (A1 m) <: A'
			% M: applys mono_nil_any D1 with E = E.
			D: applys typeSubst_chk D1.
				O: case H5. O: case O. O: apply order_subst to _ _ O with A = A1. P: case O2.
				IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ _ _ _ _. search.
			% \forall a. A1 <: \forall b. B
			O: case H5. O: case O. O: case O1.
				P: case O2. P: applys add_s_inv *P.
				IO: case H6. IO: case IO1.
				D: applys sub_sty_ty D.
				D: applys IO D3. backchain exFree_tyvar.
				W: applys sub_wft D3. W: applys esub_wft_inv W1.
				search.
			% D: assert chk E X (all A1). D: apply chk_weaken_ty to D1.
			% 	O: case H5. O: case O1. P: apply add_s_inv to O2.
			% 	IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ D2 _ _ _.
			% 		backchain exFree_tyvar. search.
		% \x. e <== A1 -> B
		D: case H9.
			% top
				Ex: applys exFree_of H11 with A = A1.
				W: applys wft_wfta H12.
				W: applys chk_wftm H13.
				W: applys esub_wftm_inv with X = lam X1. search.
			% A1 -> B <: B1 -> B2
			T: case H1. L: apply lt_sm to *H3. IT: case H2.
				D: applys sub_weaken_of D1 with X = A1.
				O: apply order_total to D2. N: apply order_is_nat to O.
				D: apply IH to _ IT _ _ O _ _ H13 D2 _ _.
					backchain exFree_of. W: apply wft_wfta to H12. search.
				D: applys esub_sub_inv D. W: apply sub_wft to D4. search.
			% % A1 -> B <: \forall b. B1
			% D: assert chk E X (arrow A1 B). D: apply chk_weaken_ty to D1.
			% 	O: case H5. O: case O1. P: apply add_s_inv to O2.
			% 	IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ D2 _ _ _.
			% 		backchain exFree_tyvar. search.
		% e <== A
		J: case H4 (keep). W: apply sub_wft to H14.
			D: apply IJ1 to _ H2 _ J _ H13 _ _.
			D: assert sub E A'1 A'. backchain sub_trans. backchain sub_trans.
			D: applys esub_sub_inv D2.
			W: case W1; try (case H9; search).
				W: applys sub_wft H9.
				W: case W2; try search.
				% bot <: forall
					O: case H5. O: case O1.
					P: applys add_s_inv.
					IO: case H6.
					S: assert sub (tyvar n1 :: E) bot (A2 n1).
					D: applys 2 IO H2 H4 IO1 S.
						backchain exFree_tyvar. backchain chk_weaken_ty.
					W: applys sub_wft D3.
					search.
				applys notAll_false H12.
	intros. Ts: apply chkInfApp_wft. D: case H6.
		D: apply esub_of_inv to _ D. D: applys esub_sub D2. search.
		W: apply Ts to D _ _. D: apply sub_refl to W.
			T: case H1. L: apply lt_sm to *H3. IT: case H2.
			O: apply order_total to D1. N: apply order_is_nat to O.
			D: apply IH to _ IT _ _ O _ _ _ _ _ _. search.
		W: apply Ts to D1 _ _. backchain exFree_tyvar.
			D: apply sub_refl to W.
			T: case H1. L: apply lt_sm to *H3. IT: case H2.
			O: apply order_total to D2. N: apply order_is_nat to O.
			D: assert esub (tyvar n1 :: E') (tyvar n1 :: E).
			D: applys IH O D3. backchain exFree_tyvar.
			S: applys sub_refl D.
			W: applys esub_wft_inv D.
			search.
		search.
		W: apply mono_wft to D. W: case W (keep).
			D: apply sub_refl to W1. D: apply sub_refl to W.
			W: case W. D: apply sub_refl to W2.
			D: applys esub_sub_inv D3.
			D: applys sub_weaken_of D4 with X = M1.
			T: case H1. L: apply lt_sm to *H3. IT: case H2.
			O: apply order_total to D4. N: apply order_is_nat to O.
			D: apply IH to _ IT _ _ O _ _ D1 _ _ _.
				backchain exFree_of. W: apply wft_wfta to W1. search.
			M: apply esub_mono_inv to _ D. search.
		N: apply tmSize_is_nat to H1. T: case H1. L: apply lt_sm to *H3. IT: case H2.
			N: case N. L: apply add_le to _ T2.
			L: apply le_trans to _ L1 _. L: apply le_trans to _ L2 _.
			D: apply IH1 to T IT _ _ _ D _ _.
			O: apply order_total to D2. N: apply order_is_nat to O.
			O: case O. P: apply add_comm to _ O2. backchain order_is_nat.
			D: apply IH2 to T1 IT _ _ _ N1 _ D1 _ _ _. search.
		T: case H1. lt: applys lt_sm *H3. IT: case H2.
			W: applys esub_wft_inv D.
			D: applys IH1. D: case D2 (keep).
				search.
				exists A1 B. applys sub_inst_bot D4 with A = A1. search.
		T: case H1. lt: applys lt_sm *H3. IT: case H2.
			D: applys IH1. D: case D2 (keep).
				exists bot. W: applys esub_wft_inv D. D: applys wft_open_a D4 D. search.
				applys notAll_false.
				exists A2 B.
					W: applys wft_weaken_f D with E = styvar n1 :: nil.
					D: applys sub_subst_wft D4 W.
					D: applys sub_strenthen_styvar_f D7.
					W: applys esub_wft_inv D.
					search.

	IO: induction on 6. intros. D: case H8 (keep).
		D: case H9.
			W: applys infApp_wft H8.
				W: applys infApp_wftm H8. W: applys esub_wftm_inv W2.
				search. % bot
			applys notAll_false.
			W: applys mono_wft D1.
				W: applys wft_weaken_f W with E = styvar n1 :: nil.
				D: applys sub_subst_wft D3 W1.
				O: case H5. O: case O. O: apply order_subst to _ _ O with A = A1. P: case O2.
					O: case O1. O: applys order_subst O1 with A = A2. P: applys add_s_inv *P.
				IO: case H6. IO: case IO1.
				D: applys sub_strenthen_styvar_f D6.
				D: apply IO to _ H2 _ H4 _ IO1 _ D _ _ _.
				W: applys sub_wft D3.
				W: assert wft E (all A2).
					applys wft_sty_ty W2. search.
				W: applys esub_wft_inv W4.
				M: applys esub_mono_inv D1.
				search.
		D: case H9.
			W: applys chk_wftm D. W: applys esub_wftm_inv. search.
			J: case H4.
			O: apply order_total to D2. N: apply order_is_nat to O.
				D: apply IJ to _ H2 _ J O _ _ _ _ _ _.
				W: apply sub_wft to D3. W: apply esub_wft_inv to _ W. search.
			O: case H5. O: case O1.
				O: apply order_subst to _ _ O1 with A = A2. P: apply add_s_inv to O2.
				IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ _ _ _ _.
				M: applys mono_nil_any with E = E'.
				W: applys sub_wft D2. W: applys wft_unsubst_all.
				W: applys esub_wft_inv W2.
				M: applys esub_mono_inv D3.
				search.
		W: applys esub_wftm_inv. D: case H9.
			search.
			O: case H5. O: case O. O: case O1.
				O: apply order_subst to _ _ O with A = A1. case O2.
				IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ _ _ _ _.
				M: applys mono_nil_any with E = E'.
				W: applys sub_wft D1. W: applys wft_unsubst_all.
				W: applys esub_wft_inv W3.
				M: applys esub_mono_inv D2.
				search.

Theorem chk_subsumption : forall E' E X A A' F,
	esub E' E -> chk E X A -> sub E A A' -> wftm F X -> wfj E -> exFree E -> chk E' X A'.
intros.
	S: apply subsumption_thm. clear S1. clear S2.
	T: apply tmSize_total to H4. N: apply tmSize_is_nat to T.
	O: apply order_total to H3. N: apply order_is_nat to O.
	D: apply S to _ _ _ _ O _ H1 H2 H3 _ _. search.

Theorem chkLam_inversion : forall E X A B, nabla t,
	chk E (lam X) (arrow A B) -> wfj E -> exFree E -> wftm E (lam X) ->
		chk (of t A :: E) (X t) B.
intros. D: case H1. search.
	D: case D1. W: apply sub_wft to D2.
		D: case D2.
		E: apply esub_eq to H2 _.
		E: assert esub (of n1 A :: E) (of n1 M1 :: E).
		W: case W. W: case H4.
		D: applys sub_weaken_of D4 with X = M1.
		D: apply chk_subsumption to E1 D3 D5 _ _ _.
			backchain exFree_of. W: apply wft_wfta to W. search.
		search.

Theorem chkLamAll_inversion : forall E X A, nabla x,
	chk E (lam X) (all A) -> wfj E -> exFree E -> wftm E (lam X) ->
	chk (tyvar x :: E) (lam X) (A x).
intros. case H1 (keep). search.
	applys notAll_false H5.


%%%%%%%%%%%% Equivalent non-overlapping declarative system %%%%%%%%%%%%
Define sub' : olist -> ty -> ty -> prop by
	sub' E i i;
	sub' E A top := wft E A;
	sub' E bot A := wft E A;
	nabla x, sub' (E x) x x := nabla x, member (tyvar x) (E x);
	nabla x, sub' (E x) x x := nabla x, member (styvar x) (E x);
	sub' E (arrow A1 A2) (arrow B1 B2) := sub' E B1 A1 /\ sub' E A2 B2;
	sub' E (all A) B := (B = top -> false) /\ notAll_ B /\ inFV A /\
											exists m, sub' E (A m) B /\ mono E m;
	sub' E (all A) (all B) := nabla x, sub' (styvar x :: E) (A x) (B x) /\ inFV A /\ inFV B.

Theorem sub'_complete_thm : forall E A B n N,
	wfj E -> sub E A B ->
	order (arrow A B) n -> lt n N -> is_nat N ->
	exFree E -> sub' E A B.
induction on 5. induction on 2. intros. case H2 (keep); try search.
	N: apply order_is_nat to H3.
		O: case H3. O: case O. O: case O1. P: apply add_assoc4 to _ _ O2.
		L: apply add_le to _ P2. L: apply le_trans to _ L _. L: apply le_trans to _ L1 _.
		D: apply IH1 to _ H7 _ L2 H5 _. D: apply IH1 to _ H8 _ L3 H5 _. search.
	O: case H3. O: case O. O: apply order_subst to _ H8 O with A = A1.
		P: case O2 (keep). L: apply lt_sm to *H4. OI: case H5.
		D: apply IH to _ H7 _ _ OI _.
		W: applys sub_wft H2. W: case W1; search.
	O: case H3. O: case O1. P: apply add_s_inv to *O2.
		O: case O. P: case P.
		L: apply lt_sm to *H4. L: applys lt_sm *L. OI: case H5. OI: case OI.
		D: apply IH to _ H7 _ _ OI _.
		backchain exFree_styvar.
		W: applys sub_wft H2. W: case W; search.

Theorem sub'_complete : forall E A B,
	sub E A B -> wfj E -> exFree E -> sub' E A B.
intros. apply order_total to H1. apply order_is_nat to H4.
	applys sub'_complete_thm with N = s m. search.

Theorem sub'_sound : forall E A B, sub' E A B -> sub E A B.
induction on 1. intros. case H1; try search.
	apply IH to H2. apply IH to H3. search.
	applys IH. search.
	applys IH. search.


Define chk' : olist -> tm -> ty -> prop,
       inf' : olist -> tm -> ty -> prop,
       infApp' : olist -> ty -> tm -> ty -> prop by
	nabla x, inf' (E x) x A := nabla x, member (of x A) (E x);
	inf' E (anno X A) A := chk' E X A;
	inf' E (tAnno X A) (all A) := nabla x, wft E (all A) /\ chk' (tyvar x :: E) (X x) (A x);
	chk' E unit i;
	inf' E unit i;
	chk' E X top := wftm E X;
	chk' E X (all A) := nabla x, chk' (tyvar x :: E) X (A x) /\ wft E (all A);
	chk' E (lam X) (arrow A B) := nabla x, wft E A /\ chk' (of x A :: E) (X x) B;
	inf' E (lam X) (arrow M1 M2) := nabla x,
		mono E (arrow M1 M2) /\ chk' (of x M1 :: E) (X x) M2;
	inf' E (app X1 X2) C := exists A, inf' E X1 A /\ infApp' E A X2 C;
	inf' E (tApp X B) bot := wft E B /\ inf' E X bot;
	inf' E (tApp X B) (A B) := wft E B /\ inf' E X (all A);
	chk' E X B := (B = top -> false) /\ notAll_ B /\ notLam_ X /\
		exists A, inf' E X A /\ sub' E A B;
	infApp' E (all A) X C := exists m, infApp' E (A m) X C /\ mono E m /\ wft E (all A);
	infApp' E (arrow A C) X C := chk' E X A /\ wft E C;
	infApp' E bot X bot := wftm E X.

Theorem chkInfApp'_complete_thm :
	(forall E X Nx NX NO A,
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat (s z) ->
			order A NO -> is_nat NO ->
		wfj E -> exFree E -> wftm E X -> chk E X A -> chk' E X A) /\
	(forall E X Nx NX A,
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat z ->
		wfj E -> exFree E -> wftm E X -> inf E X A -> inf' E X A) /\
	(forall E X Nx NX NO A C,
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat (s (s z)) ->
			order C NO -> is_nat NO ->
		wfj E -> exFree E -> wftm E X -> infApp E C X A -> infApp' E C X A).
induction on 2 2 2. IJ: induction on 4 4 4. clear IJ2. split.
	IO: induction on 5. intros. D: case H10 (keep).
		search.
		O: case H5. N: apply order_is_nat to O.
			D: apply 0 IO to H1 H2 _ H4 O _ _ _ _ D.
				backchain wftm_weaken_ty. backchain exFree_tyvar. search.
			search.
		T: case H1. L: apply lt_sm to *H3.
			IT: case H2.
			O: case H5. N: apply order_is_nat to O1.
			D: apply IH to _ IT _ _ _ _ _ _ _ D1 with NO = N2.
				backchain wftm_anyA. backchain exFree_of.
				W: apply wft_wfta to D. search.
			search.
		J: case H4 (keep). D: apply IJ1 to _ H2 _ J _ _ _ D1.
			L: assert forall x a, X = lam x -> A = all a -> chk' E X A.
				intros Eq Eq. case Eq. case Eq1.
				D: apply chkLamAll_inversion to H10 _ _ _.
				O: case H5. N: apply order_is_nat to O.
				D: apply 0 IO to _ H2 _ H4 O _ _ _ _ D4.
					backchain wftm_weaken_ty. backchain exFree_tyvar. search.
				W: applys sub_wft D2.
				search.
			L: assert forall x a b, X = lam x -> A = arrow a b -> chk' E X A.
				intros Eqx Eqa. case Eqa. case Eqx.
				D: apply chkLam_inversion to H10 _ _ _.
				T: case H1. L: apply lt_sm to *H3. T: case H2.
				O: case H5. N: apply order_is_nat to O1.
				W: apply sub_wft to D2. W: case W1.
				D: apply IH to T T1 _ _ _ _ _ _ _ D4 with NO = N2.
					backchain wftm_anyA. backchain exFree_of.
					W: apply wft_wfta to W1. search.
				search.
			D: applys sub'_complete D2. W: apply sub_wft to D2. W: case W1.
				T: case H1; try search.
					D: case D2. D: case D3. case D1. D: case D3.
				T: case H1; search.
				T: case H1; try search.
					D: case D2. D: case D3. case D1.
				T: case H1; try search.
					D: case D2. D: case D3. case D1. D: case D3. case D1.
				T: case H1; try search.
					D: case D2. D: case D3. case D1. D: case D3. case D1.
				T: case H1; try search.
					backchain L1.
				T: case H1; try search.
					backchain L.
	intros. D: case H8 (keep).
		search.
		T: case H1. L: apply lt_sm to *H3.
			IT: case H2.
			W: case H7. W: apply exFree_wfta_wft to _ *W1. O: apply order_total_wft_N to W1.
			D: apply IH to _ IT _ _ _ _ _ _ _ D with NO = N2. search.
		T: case H1. L: apply lt_sm to *H3.
			IT: case H2.
			Ex: applys exFree_tyvar.
			W: case H7. W: apply exFree_wfta_wft to _ *W1. O: apply order_total_wft_N to W1.
			O: case O. N: case O1.
			D: apply IH to _ IT _ _ _ _ _ _ _ D1 with NO = K. search.
		search.
		T: case H1. L: apply lt_sm to *H3.
			IT: case H2.
			W: case H7. W: apply wfj_exFree_wfta_wft to _ _ W.
			W: apply mono_wft to D. W: case W3. O: apply order_total_wft_N to W4.
			D: apply IH to _ IT _ _ _ _ _ _ _ D1 with NO = N2.
				backchain wftm_anyA. backchain exFree_of.
				W: apply wft_wfta to W3. search.
			search.
		N: apply tmSize_is_nat to H1. T: case H1. L: apply lt_sm to *H3.
			N: case N. L: apply add_le to _ T2.
			N: case H2.
			L: apply le_trans to _ L1 _. L: apply le_trans to _ L2 _.
			W: case H7.
			D: apply IH1 to T N1 _ _ _ _ _ D.
			Ts: apply chkInfApp_wft. W: apply Ts2 to D1 _ _.
			O: apply order_total_wft_N to W2.
			D: apply IH2 to T1 N1 _ _ _ _ _ _ _ D1 with NO = N2.
			search.
		T: case H1. L: applys lt_sm *H3. IT: case H2.
			W: case H7.
			D: applys IH1 D1.
			search.
		T: case H1. L: applys lt_sm *H3. IT: case H2.
			W: case H7.
			D: applys IH1 D1.
			search.

	IO: induction on 6. intros. D: case H10 (keep).
		O: case H5. IO: case H6. O: apply order_subst to _ D1 O with A = A1.
			D: apply IO to _ H2 _ H4 _ IO1 _ _ _ D. search.
		J: case H4.
			O: case H5. O: apply order_is_nat to O.
			D: apply IJ to H1 H2 _ J _ _ _ _ _ D with NO = M.
			search.
		search.

Theorem chk'_complete : forall E X A,
	wfj E -> exFree E -> wftm E X -> chk E X A -> chk' E X A.
intros. Ts: apply chkInfApp'_complete_thm.
	T: apply tmSize_total to H3. N: apply tmSize_is_nat to T.
	Ts: apply chkInfApp_wft. apply Ts3 to H4 _ _.
	O: apply order_total_wft_N to H5. backchain Ts with NX = s N.

Theorem inf'_complete : forall E X A,
	wfj E -> exFree E -> wftm E X -> inf E X A -> inf' E X A.
intros. Ts: apply chkInfApp'_complete_thm.
	T: apply tmSize_total to H3. N: apply tmSize_is_nat to T.
	backchain Ts1 with NX = s N.

Theorem infApp'_complete : forall E X A C,
	wfj E -> exFree E -> wftm E X -> infApp E A X C -> infApp' E A X C.
intros. Ts: apply chkInfApp'_complete_thm.
	T: apply tmSize_total to H3. N: apply tmSize_is_nat to T.
	Ts: apply chkInfApp_wft. apply Ts5 to H4 _ _.
	O: apply order_total_wft_N to H5. backchain Ts2 with NX = s N.

Theorem chkInfApp'_sound :
	(forall E X A, wftm E X -> chk' E X A -> chk E X A) /\
	(forall E X A, wftm E X -> inf' E X A -> inf E X A) /\
	(forall E X A C, wftm E X -> infApp' E C X A -> infApp E C X A).
induction on 2 2 2. split.
	intros. case H2. search. search.
		apply 0 IH to _ H3. backchain wftm_weaken_ty. search.
		apply IH to _ H4. backchain wftm_anyA. search.
		apply IH1 to _ H6. apply sub'_sound to H7. search.
	intros. case H2. search.
		W: case H1. apply IH to _ H3. search.
		W: case H1. applys IH. search.
		search.
		W: apply mono_wft to H3. W: case W.
			apply IH to _ H4. backchain wftm_anyA. search.
		W: case H1. apply IH1 to _ H3. apply IH2 to _ H4. search.
		W: case H1. applys IH1. search.
		W: case H1. applys IH1. search.
	intros. case H2.
		apply IH2 to _ H3. search.
		apply IH to _ H3. search.
		search.


Theorem wft_inst : forall E A m,
	wft E (all A) -> wft E m -> wft E (A m).
intros W W. W: case W.
	W: applys wft_subst W with T = A, m = m. backchain wft_weaken_ty.
	applys wft_strenthen_tyvar W3. search.

Theorem wft_inst_mono : forall E A m,
	wft E (all A) -> mono E m -> wft E (A m).
intros. applys mono_wft H2. applys wft_inst H1 H3. search.

