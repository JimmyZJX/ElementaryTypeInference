Import "instDecidability".

Define tmSizeJ : judgment -> nat -> prop by
	tmSizeJ (subty A B) z;
	tmSizeJ (check X A) N := tmSize X N;
	tmSizeJ (inferC X Ji) K := exists M N, nabla x,
		tmSize X M /\ tmSizeJ (Ji x) N /\ add M N K;
	tmSizeJ (typeAppC A B Ji) N := nabla x, tmSizeJ (Ji x) N;
	tmSizeJ (inferAppC A X Ji) K := exists M N, nabla x,
		tmSize X M /\ tmSizeJ (Ji x) N /\ add M N K.

Define tmSizel : olist -> nat -> prop by
	tmSizel nil z;
	nabla x, tmSizel (exvar x :: E x) N := nabla x, tmSizel (E x) N;
	nabla x, tmSizel (tyvar x :: E x) N := nabla x, tmSizel (E x) N;
	nabla x, tmSizel (styvar x :: E x) N := nabla x, tmSizel (E x) N;
	nabla x, tmSizel (of x A :: E x) N := nabla x, tmSizel (E x) N;
	tmSizel (j J :: E) K := exists M N, tmSizeJ J M /\ tmSizel E N /\ add M N K.

Theorem tmSizeJ_is_nat : forall J N, tmSizeJ J N -> is_nat N.
induction on 1. intros. case H1. search.
	backchain tmSize_is_nat.
	apply IH to H3. apply add_is_nat_k to _ H4. search.
	applys IH. search.
	apply IH to H3. apply add_is_nat_k to _ H4. search.

Theorem nat_prune_ty : forall N, nabla (x : ty), is_nat (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search. apply IH to H2. search.

Theorem nat_prune_tm : forall N, nabla (x : tm), is_nat (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search. apply IH to H2. search.

Theorem tmSizel_is_nat : forall E N, tmSizel E N -> is_nat N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H3. apply add_is_nat_k to _ H4. search.

Theorem tmSizel_prune : forall E N, nabla (x : ty),
	tmSizel (E x) (N x) -> exists Nr, N = x\ Nr.
intros. apply tmSizel_is_nat to H1.
	apply nat_prune_ty to H2. search.

Theorem tmSizel_prune_tm : forall E N, nabla (x : tm),
	tmSizel (E x) (N x) -> exists Nr, N = x\ Nr.
intros. apply tmSizel_is_nat to H1.
	apply nat_prune_tm to H2. search.

Theorem tmSizeJ_subst_eq : forall J A N N1, nabla (x : ty),
	tmSizeJ (J x) N -> tmSizeJ (J (A x)) N1 -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply tmSize_subst to H3 with A = A. apply tmSize_det to H4 H5. search.
	case H2. apply tmSize_prune to H3.
		apply tmSize_subst to H3 with A = A. apply tmSize_det to H6 H9.
		apply tmSizeJ_is_nat to H4. apply nat_prune_ty to H10. apply add_prune[ty] to H8.
		apply IH to H4 _ with J = x\ Ji x n2, A = A.
		apply add_det to H5 H8. search.
	case H2. applys IH H4. search.
	case H2. apply tmSize_prune to H3.
		apply tmSize_subst to H3 with A = A. apply tmSize_det to H6 H9.
		apply tmSizeJ_is_nat to H4. apply nat_prune_ty to H10. apply add_prune[ty] to H8.
		apply IH to H4 _ with J = x\ Ji x n2, A = A.
		apply add_det to H5 H8. search.

Theorem tmSizel_subst_eq : forall E A N N1, nabla (x : ty),
	tmSizel (E x) N -> tmSizel (E A) N1 -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply tmSizel_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply tmSizel_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply tmSizel_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply tmSizel_prune to H4.
		apply tmSizeJ_is_nat to H3. apply nat_prune_ty to H9.
		apply IH to H4 H7. apply tmSizeJ_subst_eq to H3 _ with A = x\ A.
		apply add_det to H5 H8. search.
Theorem tmSizel_det : forall E N N1, tmSizel E N -> tmSizel E N1 -> N = N1.
intros. apply tmSizel_subst_eq to H1 H2. search.

Theorem tmSizel_append : forall E F EF NE NF NEF, tmSizel E NE -> tmSizel F NF ->
	append E F EF -> add NE NF NEF -> tmSizel EF NEF.
induction on 1. intros. case H1.
	case H3. case H4. search.
	case H3. apply IH to H5 _ _ _. apply tmSizel_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply tmSizel_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply tmSizel_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply tmSizel_prune_tm to H7. search.
	case H3. apply add_assoc to H7 _.
		apply IH to H6 _ _ _. search.

Theorem tmSizel_total_wfjg : forall E J, wfjg E J -> exists N, tmSizel (j J :: nil) N.
induction on 1. intros. case H1.
	search.
	apply tmSize_total to H2.
		N: apply tmSize_is_nat to H4.
		apply add_total to N with n = z. search.
	apply IH to H3. apply tmSize_total to H2.
		N: apply tmSize_is_nat to H5.
		case H4. case H7. apply add_z_eq to *H8.
		apply tmSizeJ_is_nat to H6. apply nat_prune_ty to H9.
		apply add_total to N with n = Nr.
		apply add_is_nat_k to _ H10. apply add_zero to H11.
		search.
	apply IH to H4. apply tmSize_total to H2.
		N: apply tmSize_is_nat to H6.
		case H5. case H8. apply add_z_eq to *H9.
		apply tmSizeJ_is_nat to H7. apply nat_prune_ty to H10.
		apply add_total to N with n = Nr.
		apply add_is_nat_k to _ H11. apply add_zero to H12.
		search.
	apply IH to H4.
		case H5. case H7. applys add_z_eq *H8.
		N: applys tmSizeJ_is_nat H6. applys nat_prune_ty N.
		P: applys add_zero N.
		search.


Theorem tmSizeJ_total : forall E J, wfjg E J -> exists N, tmSizeJ J N.
induction on 1. intros. case H1.
	search.
	apply tmSize_total to H2. search.
	apply tmSize_total to H2. apply IH to H3.
		apply tmSizeJ_is_nat to H5. apply nat_prune_ty to H6.
		apply tmSize_is_nat to H4. apply add_total to H7 with n = Nr. search.
	apply tmSize_total to H2. apply IH to H4.
		apply tmSizeJ_is_nat to H6. apply nat_prune_ty to H7.
		apply tmSize_is_nat to H5. apply add_total to H8 with n = Nr. search.
	applys IH.
		N: applys tmSizeJ_is_nat H5. applys nat_prune_ty.
		search.

Theorem tmSizel_total_wfj : forall E, wfj E -> exists N, tmSizel E N.
induction on 1. intros. case H1.
	search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. apply tmSizeJ_total to H3.
		apply tmSizeJ_is_nat to H5. apply add_total to H6 with n = N. search.

Theorem tmSizel_total_FE : forall F E FE, append F E FE -> wfj FE ->
	exists NF NE NFE, tmSizel F NF /\ tmSizel E NE /\ tmSizel FE NFE /\ add NF NE NFE.
induction on 2. intros. case H2.
	case H1. search.
	case H1. apply IH to _ H3. search.
		apply append_prune to H4. apply IH to H4 H3. search.
	case H1. apply IH to _ H3. search.
		apply append_prune to H4. apply IH to H4 H3. search.
	case H1. apply IH to _ H3. search.
		apply append_prune to H4. apply IH to H4 H3. search.
	case H1. apply IH to _ H3. search.
		apply append_prune_tm to H5. apply IH to H5 H3. search.
	apply tmSizeJ_total to H4. apply tmSizeJ_is_nat to H5.
		case H1. apply IH to _ H3. apply add_total to H6 with n = NE. search.
		apply IH to _ H3. apply add_total to H6 with n = NFE.
			apply add_assoc_inv to H11 H12. search.

Theorem tmSizel_total_nat : forall E, wfj E -> exists NE, tmSizel E NE /\ is_nat NE.
intros. apply tmSizel_total_wfj to H1. apply tmSizel_is_nat to H2. search.

Theorem jExt_tmSizel_eq : forall E Ext NE NExt,
	wfj E -> jExt E Ext -> tmSizel E NE -> tmSizel Ext NExt -> NE = NExt.
induction on 2. intros. case H2 (keep).
	apply tmSizel_det to H3 H4. search.
	apply tmSizel_total_FE to H5 _. case H12. apply tmSizel_det to *H3 H13.
		apply tmSizel_append to _ _ H6 _.
		W: apply wfj_remove_exvar_nabla to H5 H6 _ _. apply tmSizel_total_wfj to W.
		applys IH.
		apply tmSizel_prune to H16. apply tmSizel_subst_eq to H16 H17. search.
	apply tmSizel_total_FE to H5 _. apply tmSizel_det to *H3 H10.
		apply tmSizel_append to _ _ H6 _.
		W: apply wfj_insert_exvar_raw to H5 H6 _. apply tmSizel_total_wfj to W.
		apply IH to _ H7 H13 H4.
		apply tmSizel_prune to H13. apply tmSizel_det to H12 H13. search.
Theorem jExt_tmSizel : forall E Ext NE,
	wfj E -> jExt E Ext -> tmSizel E NE -> tmSizel Ext NE.
intros. apply jExt_wfj to _ _. apply tmSizel_total_wfj to H4.
	apply jExt_tmSizel_eq to _ _ H3 H5. search.

% Theorem tmSizel_subst_tyvar : forall E J m N, nabla x,
% 	tmSizel (j (J x) :: tyvar x :: E) N -> wfj (j (J x) :: tyvar x :: E) ->
% 	wfta E m -> wfj (j (J m) :: E) /\ tmSizel (j (J m) :: E) N.
% intros. T: apply tmSizel_total_FE to _ H2 with E = tyvar n1 :: E.
% 	W: apply wfj_subst_tyvar to H2 _.
% 	T: apply tmSizel_total_FE to _ W with E = E.
% 	T: case T1. apply tmSizel_det to T5 *T1.
% 	apply tmSizel_prune to T. apply tmSizel_subst_eq to T T4.
% 	apply add_det to T3 T7. apply tmSizel_det to H1 T2. search.


Define m_judgeJ : judgment -> nat -> prop by
	m_judgeJ (subty A B) z;
	m_judgeJ (check X A) (s (s z));
	m_judgeJ (inferC X Ji) (s N) := nabla x, m_judgeJ (Ji x) N;
	m_judgeJ (inferAppC A X Ji) (s (s (s N))) := nabla x, m_judgeJ (Ji x) N;
	m_judgeJ (typeAppC A X Ji) (s N) := nabla x, m_judgeJ (Ji x) N.

Theorem m_judgeJ_is_nat : forall J N, m_judgeJ J N -> is_nat N.
induction on 1. intros. case H1.
	search. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.

Define m_judge : olist -> nat -> prop by
	m_judge nil z;
	nabla x, m_judge (exvar x :: E x) N := nabla x, m_judge (E x) N;
	nabla x, m_judge (tyvar x :: E x) N := nabla x, m_judge (E x) N;
	nabla x, m_judge (styvar x :: E x) N := nabla x, m_judge (E x) N;
	nabla x, m_judge (of x A :: E x) N := nabla x, m_judge (E x) N;
	m_judge (j J :: E) K := exists M N,
		m_judgeJ J M /\ m_judge E N /\ add M N K.

Theorem m_judge_is_nat : forall E N, m_judge E N -> is_nat N.
induction on 1. intros. case H1; try applys IH; try search.
	apply IH to H3. apply add_is_nat_k to H5 H4. search.

Theorem m_judge_prune : forall E N, nabla (x : ty),
	m_judge (E x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H2 with x = n1. search.
	apply IH to H3. apply m_judge_is_nat to H3.
		apply add_is_nat_k to _ H4. apply nat_prune_ty to H6. search.

Theorem m_judge_prune_tm : forall E N, nabla (x : tm),
	m_judge (E x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H2 with x = n1. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H3. apply m_judge_is_nat to H3.
		apply add_is_nat_k to _ H4. apply nat_prune_tm to H6. search.

Theorem m_judgeJ_subst_eq : forall J A N N1, nabla (x : ty),
	m_judgeJ (J x) N -> m_judgeJ (J (A x)) N1 -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. search.
	case H2. apply IH to H3 _ with J = x\ Ji x n2, A = A. search.
	case H2. apply IH to H3 _ with J = x\ Ji x n2, A = A. search.
	case H2. apply IH to H3 _ with J = x\ Ji x n2, A = A. search.

Theorem m_judge_subst_eq : forall E A N N1, nabla (x : ty),
	m_judge (E x) N -> m_judge (E A) N1 -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply m_judge_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply m_judge_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply m_judge_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply m_judge_prune to H4.
		apply IH to H4 _ with A = A.
		apply m_judgeJ_is_nat to H3. apply nat_prune_ty to H9.
		apply m_judgeJ_subst_eq to H3 H6.
		backchain add_det.
Theorem m_judge_det : forall E N N1, m_judge E N -> m_judge E N1 -> N = N1.
intros. apply m_judge_subst_eq to H1 H2. search.

Theorem m_judge_append : forall E F EF NE NF NEF,
	m_judge E NE -> m_judge F NF ->
	append E F EF -> add NE NF NEF -> m_judge EF NEF.
induction on 1. intros. case H1.
	case H3. case H4. search.
	case H3. apply IH to H5 _ _ _. apply m_judge_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply m_judge_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply m_judge_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply m_judge_prune_tm to H7. search.
	case H3. apply add_assoc to H7 H4. apply IH to H6 _ _ _. search.

Theorem m_judgeJ_total_wfjg : forall E J, wfjg E J -> exists N, m_judgeJ J N.
induction on 1. intros. case H1. search. search.
	apply IH to H3. apply m_judgeJ_is_nat to H4. apply nat_prune_ty to H5. search.
	apply IH to H4. apply m_judgeJ_is_nat to H5. apply nat_prune_ty to H6. search.
	apply IH to H4. apply m_judgeJ_is_nat to H5. apply nat_prune_ty to H6. search.

Theorem m_judge_total_wfj : forall E, wfj E -> exists N, m_judge E N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2.
		apply m_judgeJ_total_wfjg to H3. apply m_judgeJ_is_nat to H5.
		apply add_total to H6 with n = N. search.

Theorem m_judge_total_FE : forall F E FE, append F E FE -> wfj FE ->
	exists NF NE NFE, m_judge F NF /\ m_judge E NE /\
		m_judge FE NFE /\ add NF NE NFE.
induction on 1. intros. case H1.
	apply m_judge_total_wfj to H2. search.
	W: case H2.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune_tm to H3. apply IH to H3 _. search.
		apply IH to H3 _. apply m_judgeJ_total_wfjg to W1.
			N: apply m_judgeJ_is_nat to H8.
			apply add_total to N with n = NFE.
			apply add_assoc_inv to H7 H9. search.

Theorem m_judge_total_nat : forall E, wfj E -> exists NE, m_judge E NE /\ is_nat NE.
intros. apply m_judge_total_wfj to H1. apply m_judge_is_nat to H2. search.

Theorem jExt_m_judge_eq : forall E Ext NE NExt,
	wfj E -> jExt E Ext -> m_judge E NE -> m_judge Ext NExt -> NE = NExt.
induction on 2. intros. case H2 (keep).
	apply m_judge_det to H3 H4. search.
	apply m_judge_total_FE to H5 _. case H12. apply m_judge_det to *H3 H13.
		apply m_judge_append to _ _ H6 _.
		W: apply wfj_remove_exvar_nabla to H5 H6 _ _. apply m_judge_total_wfj to W.
		applys IH.
		apply m_judge_prune to H16. apply m_judge_subst_eq to H16 H17. search.
	apply m_judge_total_FE to H5 _. apply m_judge_det to *H3 H10.
		apply m_judge_append to _ _ H6 _.
		W: apply wfj_insert_exvar_raw to H5 H6 _. apply m_judge_total_wfj to W.
		apply IH to _ H7 H13 H4.
		apply m_judge_prune to H13. apply m_judge_det to H12 H13. search.
Theorem jExt_m_judge : forall E Ext NE,
	wfj E -> jExt E Ext -> m_judge E NE -> m_judge Ext NE.
intros. apply jExt_wfj to _ _. apply m_judge_total_wfj to H4.
	apply jExt_m_judge_eq to _ _ H3 H5. search.

% Theorem m_judge_subst_tyvar : forall E J m N, nabla x,
% 	m_judge (j (J x) :: tyvar x :: E) N -> wfj (j (J x) :: tyvar x :: E) ->
% 	wfta E m -> wfj (j (J m) :: E) /\ m_judge (j (J m) :: E) N.
% intros. T: apply m_judge_total_FE to _ H2 with E = tyvar n1 :: E.
% 	W: apply wfj_subst_tyvar to H2 _.
% 	T: apply m_judge_total_FE to _ W with E = E.
% 	T: case T1. apply m_judge_det to T5 *T1.
% 	apply m_judge_prune to T. apply m_judge_subst_eq to T T4.
% 	apply add_det to T3 T7. apply m_judge_det to H1 T2. search.


Theorem orderl_append : forall E F EF NE NF NEF,
	orderl E NE -> orderl F NF ->
	append E F EF -> add NE NF NEF -> orderl EF NEF.
induction on 1. intros. case H1 (keep).
	case H3. case H4. search.
	case H3. apply IH to H5 _ _ _. apply orderl_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply orderl_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply orderl_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply orderl_prune_tm to H7. search.
	case H3. apply add_assoc to H7 _. apply IH to H6 _ _ _. search.

Theorem orderJ_total_wfjg : forall E J, wfjg E J -> exists N, orderJ J N.
induction on 1. intros. case H1.
	O: apply order_total_wf to H2. O: apply order_total_wf to H3.
		N: apply order_is_nat to O.
		apply add_total to N with n = m1. search.
	O: apply order_total_wf to H3. search.
	apply IH to H3. apply orderJ_prune to H4. search.
	O: apply order_total_wf to H3. N: apply order_is_nat to O.
		apply IH to H4. apply orderJ_prune to H5.
		apply add_total to N with n = Nr. search.
	O: apply order_total_wf to H3. N: apply order_is_nat to O.
		apply IH to H4. apply orderJ_prune to H5.
		apply add_total to N with n = Nr. search.

Theorem orderl_total_wfj : forall E, wfj E -> exists N, orderl E N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. apply orderJ_total_wfjg to H3.
		apply orderJ_is_nat to H5.
		apply add_total to H6 with n = N. search.

Theorem orderl_total_FE : forall F E FE, append F E FE -> wfj FE ->
	exists NF NE NFE, orderl F NF /\ orderl E NE /\
		orderl FE NFE /\ add NF NE NFE.
induction on 1. intros. case H1.
	apply orderl_total_wfj to H2. search.
	case H2.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune_tm to H3. apply IH to H3 _. search.
		apply IH to H3 _. apply orderJ_total_wfjg to H5.
			N: apply orderJ_is_nat to H10.
			apply add_total to N with n = NFE.
			apply add_assoc_inv to H9 _. search.

Theorem orderl_total_nat : forall E, wfj E -> exists NE, orderl E NE /\ is_nat NE.
intros. apply orderl_total_wfj to H1. apply orderl_is_nat to H2. search.

Theorem order_det : forall A N1 N2, order A N1 -> order A N2 -> N1 = N2.
induction on 1. intros. case H1.
	case H2. search.
	case H2. search.
	case H2. search.
	case H2. search.
	case H2. apply IH to H3 H6. apply IH to H4 H7. apply add_det to H5 H8. search.
	case H2. apply IH to H3 H4. search.

Theorem order_subst_eq : forall A a N N1, nabla (x : ty),
	order (A x) N -> order (A a) N1 -> order a z -> N = N1.
induction on 1. intros. case H1 (keep).
	case H2. search.
	case H2. search.
	case H2. search.
	case H2. search.
	apply order_det to H2 H3. search.
	apply order_prune to H4. apply order_prune to H5.
		case H2. apply IH to H4 _ _. apply IH to H5 _ _. apply add_det to H6 H9. search.
	case H2. apply IH to H4 _ _. search.

Theorem orderJ_subst_eq : forall J A N N1, nabla (x : ty),
	orderJ (J x) N -> orderJ (J A) N1 -> order A z -> N = N1.
induction on 1. intros. case H1.
	case H2. apply order_prune to H4. apply order_prune to H5.
		apply order_subst_eq to H4 _ H3. apply order_subst_eq to H5 _ H3.
		apply add_det to H6 H9. search.
	case H2. apply order_subst_eq to H4 _ H3. search.
	case H2. apply IH to H4 _ H3 with J = x\ Ji x n2. search.
	case H2. apply IH to H4 _ H3 with J = x\ Ji x n2. search.
	case H2. apply add_prune to H6. apply add_prune to H6. apply add_prune to H9.
		apply order_subst_eq to H4 _ H3.
		apply IH to H5 _ H3.
		apply add_det to H6 H9. search.

Theorem orderl_subst_eq : forall E A N N1, nabla (x : ty),
	orderl (E x) N -> orderl (E A) N1 -> order A z -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply orderl_prune to H4 with x = n2. apply IH to H4 H5 _. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply orderl_prune to H4 with x = n2. apply IH to H4 H5 _. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply orderl_prune to H4 with x = n2. apply IH to H4 H5 _. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply add_prune to H6. apply IH to H5 _ H3.
		apply orderJ_subst_eq to H4 _ H3.
		apply add_det to H6 H9. search.
Theorem orderl_det : forall E N N1, orderl E N -> orderl E N1 -> N = N1.
intros. apply orderl_subst_eq to H1 H2 _. search.

% Theorem orderl_subst_tyvar : forall E J m N, nabla x,
% 	orderl (j (J x) :: tyvar x :: E) N -> wfj (j (J x) :: tyvar x :: E) ->
% 	wfta E m -> order m z -> wfj (j (J m) :: E) /\ orderl (j (J m) :: E) N.
% intros. T: apply orderl_total_FE to _ H2 with E = tyvar n1 :: E.
% 	W: apply wfj_subst_tyvar to H2 _.
% 	T: apply orderl_total_FE to _ W with E = E.
% 	T: case T1. apply orderl_det to T5 *T1.
% 	apply orderl_prune to T. apply orderl_subst_eq to T T4 _.
% 	apply add_det to T3 T7. apply orderl_det to H1 T2. search.

Theorem jExt_orderl_eq : forall E Ext NE NExt,
	wfj E -> jExt E Ext -> orderl E NE -> orderl Ext NExt -> NE = NExt.
induction on 2. intros. case H2 (keep).
	apply orderl_det to H3 H4. search.
	apply orderl_total_FE to H5 _. case H12. apply orderl_det to *H3 H13.
		apply orderl_append to _ _ H6 _.
		W: apply wfj_remove_exvar_nabla to H5 H6 _ _. apply orderl_total_wfj to W.
		applys IH.
		apply orderl_prune to H16. apply orderl_subst_eq to H16 H17 _. search.
	apply orderl_total_FE to H5 _. apply orderl_det to *H3 H10.
		apply orderl_append to _ _ H6 _.
		W: apply wfj_insert_exvar_raw to H5 H6 _. apply orderl_total_wfj to W.
		apply IH to _ H7 H13 H4.
		apply orderl_prune to H13. apply orderl_det to H12 H13. search.
Theorem jExt_orderl : forall E Ext NE,
	wfj E -> jExt E Ext -> orderl E NE -> orderl Ext NE.
intros. apply jExt_wfj to _ _. apply orderl_total_wfj to H4.
	apply jExt_orderl_eq to _ _ H3 H5. search.





Theorem nTB_append : forall E F EF NE NF NEF,
	nTB E NE -> nTB F NF ->
	append E F EF -> add NE NF NEF -> nTB EF NEF.
induction on 1. intros. case H1 (keep).
	case H3. case H4. search.
	case H3. applys IH. apply nTB_prune to H7. search.
	case H3. applys IH. apply nTB_prune to H7. search.
	case H3. applys IH. apply nTB_prune to H7. search.
	case H3. applys IH. apply nTB_prune_tm to H7. search.
	case H3. apply add_assoc to H7 _. apply IH to H6 _ _ _. search.

Theorem nTB_total_wfjg : forall E J, wfjg E J -> exists N, nTBJ J N.
induction on 1. intros. case H1.
	TB: applys nTopBot_wf_total H2. TB: applys nTopBot_wf_total H3.
		N: applys nTopBot_is_nat TB.
		applys add_total N with n = NTB1. search.
	TB: applys nTopBot_wf_total H3. search.
	applys IH. apply nTBJ_prune to H4. search.
	TB: applys nTopBot_wf_total H3. N: apply nTopBot_is_nat to TB.
		apply IH to H4. apply nTBJ_prune to H5.
		apply add_total to N with n = Nr. search.
	TB: applys nTopBot_wf_total H3. N: apply nTopBot_is_nat to TB.
		apply IH to H4. apply nTBJ_prune to H5.
		apply add_total to N with n = Nr. search.

Theorem nTB_total_wfj : forall E, wfj E -> exists N, nTB E N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. apply nTB_total_wfjg to H3.
		apply nTBJ_is_nat to H5.
		apply add_total to H6 with n = N. search.

Theorem nTB_total_FE : forall F E FE, append F E FE -> wfj FE ->
	exists NF NE NFE, nTB F NF /\ nTB E NE /\
		nTB FE NFE /\ add NF NE NFE.
induction on 1. intros. case H1.
	apply nTB_total_wfj to H2. search.
	case H2.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune_tm to H3. apply IH to H3 _. search.
		apply IH to H3 _. apply nTB_total_wfjg to H5.
			N: apply nTBJ_is_nat to H10.
			apply add_total to N with n = NFE.
			apply add_assoc_inv to H9 _. search.

Theorem nTB_total_nat : forall E, wfj E -> exists NE, nTB E NE /\ is_nat NE.
intros. apply nTB_total_wfj to H1. apply nTB_is_nat to H2. search.

Theorem nTopBot_det : forall A N1 N2, nTopBot A N1 -> nTopBot A N2 -> N1 = N2.
induction on 1. intros. case H1.
	case H2. search.
	case H2. search.
	case H2. search.
	case H2. search.
	case H2. apply IH to H3 H6. apply IH to H4 H7. apply add_det to H5 H8. search.
	case H2. apply IH to H3 H4. search.

Theorem nTopBot_subst_eq : forall A a N N1, nabla (x : ty),
	nTopBot (A x) N -> nTopBot (A a) N1 -> nTopBot a z -> N = N1.
induction on 1. intros. case H1 (keep).
	case H2. search.
	case H2. search.
	case H2. search.
	case H2. search.
	apply nTopBot_det to H2 H3. search.
	apply nTopBot_prune to H4. apply nTopBot_prune to H5.
		case H2. apply IH to H4 _ _. apply IH to H5 _ _. apply add_det to H6 H9. search.
	case H2. apply IH to H4 _ _. search.

Theorem nTBJ_subst_eq : forall J A N N1, nabla (x : ty),
	nTBJ (J x) N -> nTBJ (J A) N1 -> nTopBot A z -> N = N1.
induction on 1. intros. case H1.
	case H2. apply nTopBot_prune to H4. apply nTopBot_prune to H5.
		apply nTopBot_subst_eq to H4 _ H3. apply nTopBot_subst_eq to H5 _ H3.
		apply add_det to H6 H9. search.
	case H2. search.
	case H2. search.
	case H2. search.
	case H2. search.

Theorem nTB_subst_eq : forall E A N N1, nabla (x : ty),
	nTB (E x) N -> nTB (E A) N1 -> nTopBot A z -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply nTB_prune to H4 with x = n2. apply IH to H4 H5 _. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply nTB_prune to H4 with x = n2. apply IH to H4 H5 _. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply nTB_prune to H4 with x = n2. apply IH to H4 H5 _. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply add_prune to H6. apply IH to H5 _ H3.
		apply nTBJ_subst_eq to H4 _ H3.
		apply add_det to H6 H9. search.
Theorem nTB_det : forall E N N1, nTB E N -> nTB E N1 -> N = N1.
intros. apply nTB_subst_eq to H1 H2 _. search.

Theorem jExt_nTB_eq : forall E Ext NE NExt,
	wfj E -> jExt E Ext -> nTB E NE -> nTB Ext NExt -> NE = NExt.
induction on 2. intros. case H2 (keep).
	apply nTB_det to H3 H4. search.
	apply nTB_total_FE to H5 _. case H12. apply nTB_det to *H3 H13.
		apply nTB_append to _ _ H6 _.
		W: apply wfj_remove_exvar_nabla to H5 H6 _ _. apply nTB_total_wfj to W.
		apply IH to _ H10 H17 H4.
		apply nTB_prune to H16. apply nTB_subst_eq to H16 H17 _. search.
	apply nTB_total_FE to H5 _. apply nTB_det to *H3 H10.
		apply nTB_append to _ _ H6 _.
		W: apply wfj_insert_exvar_raw to H5 H6 _. apply nTB_total_wfj to W.
		apply IH to _ H7 H13 H4.
		apply nTB_prune to H13. apply nTB_det to H12 H13. search.
Theorem jExt_nTB : forall E Ext NE,
	wfj E -> jExt E Ext -> nTB E NE -> nTB Ext NE.
intros. apply jExt_wfj to _ _. apply nTB_total_wfj to H4.
	apply jExt_nTB_eq to _ _ H3 H5. search.





Define depthJ : judgment -> nat -> prop by
	depthJ (subty A B) K := exists M N, depth A M /\ depth B N /\ add M N K;
	depthJ (check X A) N := depth A N;
	depthJ (inferC X J) N := nabla x, depthJ (J x) N;
	depthJ (typeAppC A B J) N := nabla x, depthJ (J x) N;
	depthJ (inferAppC A X J) K := exists M N, nabla x,
		depth A M /\ depthJ (J x) N /\ add M N K.

Theorem depthJ_is_nat : forall J N, depthJ J N -> is_nat N.
induction on 1. intros. case H1.
	apply depth_is_nat to H3. apply add_is_nat_k to _ H4. search.
	backchain depth_is_nat.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H3. backchain add_is_nat_k.

Theorem depthJ_total_wfjg : forall E J, wfjg E J -> exists N, depthJ J N.
induction on 1. intros. case H1.
	apply depth_wfta_total to H2. apply depth_wfta_total to H3.
		apply depth_is_nat to H4.
		apply add_total to H6 with n = N1. search.
	apply depth_wfta_total to H3. search.
	apply IH to H3. apply depthJ_is_nat to H4.
		apply nat_prune_ty to H5. search.
	apply IH to H4. apply depthJ_is_nat to H5. apply nat_prune_ty to H6.
		apply depth_wfta_total to H3. apply depth_is_nat to H7.
		apply add_total to H8 with n = Nr. search.
	apply IH to H4. apply depthJ_is_nat to H5. apply nat_prune_ty to H6.
		apply depth_wfta_total to H3. apply depth_is_nat to H7.
		apply add_total to H8 with n = Nr. search.

Define depthl : olist -> nat -> prop by
	depthl nil z;
	nabla x, depthl (exvar x :: E) (s N) := depthl E N;
	nabla x, depthl (tyvar x :: E) (s N) := depthl E N;
	nabla x, depthl (styvar x :: E) (s N) := depthl E N;
	nabla x, depthl (of x A :: E) (s N) := depthl E N;
	depthl (j J :: E) (s K) := exists M N, depthJ J M /\ depthl E N /\ add M N K.

Theorem depthl_prune : forall E N, nabla (x : ty),
	depthl (E x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1.
	search.
	apply IH to H2. search.
	search.
	apply IH to H2. search.
	search.
	apply IH to H2. search.
	search.
	apply IH to H2. search.
	apply depthJ_is_nat to H2. apply nat_prune_ty to H5.
		apply IH to H3. apply add_prune_k[ty] to H4. search.

Theorem depthl_total : forall E, wfj E -> exists N, depthl E N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. apply depthJ_total_wfjg to H3.
		apply depthJ_is_nat to H5.
		apply add_total to H6 with n = N. search.

Theorem depthl_is_nat : forall E N, depthl E N -> is_nat N.
induction on 1. intros. case H1; try applys IH; try search.
	apply IH to H3. apply add_is_nat_k to _ H4. search.
Theorem depthl_total_nat : forall E, wfj E -> exists NE, depthl E NE /\ is_nat NE.
intros. apply depthl_total to H1. apply depthl_is_nat to H2. search.


Theorem subExp_tmSizel_z : forall Exp, subExp Exp -> tmSizel Exp z.
induction on 1. intros. case H1. search.
	apply IH to H2. search. apply IH to H2. search. apply IH to H2. search.
Theorem subExp_m_judge_z : forall Exp, subExp Exp -> m_judge Exp z.
induction on 1. intros. case H1. search.
	apply IH to H2. search. apply IH to H2. search. apply IH to H2. search.

Define fresh_ty : ty -> ty -> prop by
  nabla x, fresh_ty x A.

Theorem equivJ_decidable : forall E F,
	equivJ E F -> (judge F \/ (judge F -> false)) -> (judge E \/ (judge E -> false)).
intros. case H1. case H2. apply H4 to H5. search.
	right. intros. backchain H5. backchain H3.

Theorem fv_decidable : forall E A, nabla (x : ty), wfta (E x) (A x) ->
	(exists Ar, A = x\ Ar) \/ ((exists Ar, A = x\ Ar) -> false).
induction on 1. intros. case H1; try search.
	apply IH to H2. apply IH to H3. case H4.
		case H5. search. right. intros. case H7. backchain H6.
		right. intros. case H7. backchain H6.
	apply IH to H2. case H4. search. right. intros. case H6. backchain H5.

Define all_ : ty -> prop by
	all_ (all A).

Theorem tex_inferLam_sync : forall E Jo X W,
	wfj E -> tex (j (inferC (lam X) W) :: E) Jo ->
		exists x w Jr, Jo = j (inferC (lam x) w) :: Jr.
induction on 2. intros. case H2.
	apply exFree_weaken to H3. search.
	case H3. case H4.
		apply wfj_remove_exvar_mono to H8 H9 _ _.
		applys IH. search.

Theorem judge_inferLam_arrow_sub_bot_false : forall E X,
	wfj (j (inferC (lam X) (r\subty r bot)) :: E) ->
	judge (j (inferC (lam X) (r\subty r bot)) :: E) -> false.
intros W Jg. T: applys soundness.
	W: case W.
	T: applys tex_infSub_sync.
	D: case T1. D: case D1.
	T: applys tex_inferLam_sync.
	D: case D.
	applys tex_wft_chk.
	case D1.

Theorem decidable_thm : forall E NT NT_I NJ NO NTB NTB_I NV ND, wfj E ->
	tmSizel E NT -> is_nat NT_I -> lt NT NT_I ->
	m_judge E NJ -> is_nat NJ ->
	nTB E NTB -> is_nat NTB_I -> lt NTB NTB_I ->
	orderl E NO -> is_nat NO ->
	nVar E NV -> is_nat NV ->
	depthl E ND -> is_nat ND ->
	judge E \/ (judge E -> false).
induction on 3. induction on 6. induction on 8.
induction on 11. induction on 13. induction on 15.
intros W T IT ltT J IJ TB ITB ltTB O IO V IV D ID. W: case W. search.
	% E, a
	T: case T. J: case J. O: case O. TB: case TB. V: case V. D: case D. ID: case ID.
		Jg: applys IH5. Jg: case Jg.
		search. right. intros. case H1. backchain Jg.
	% E, ~a
	T: case T. J: case J. O: case O. TB: case TB. V: case V. D: case D. ID: case ID.
		Jg: applys IH5. Jg: case Jg.
		search. right. intros. case H1. backchain Jg.
	% E, ^a
	T: case T. J: case J. O: case O. TB: case TB. V: case V. D: case D.
		IV: case IV. ID: case ID.
		Jg: applys IH4 D. Jg: case Jg.
		search. right. intros. case H1. backchain Jg.
	% E, x:A
	T: case T. J: case J. O: case O. TB: case TB. V: case V. D: case D. ID: case ID.
		Jg: applys IH5. Jg: case Jg.
		search. right. intros. case H1. backchain Jg.
	% E, J
	W: case W1.
	% E, A <: B
	T: case T. J: case J. V: case V. clear IH IH1.
		Linst: assert name A -> member (exvar A) E1 -> fresh_ty A B ->
			judge (j (subty A B) :: E1) \/ (judge (j (subty A B) :: E1) -> false).
			intros A M B. case A. case B.
			Jg: apply instantiation_decidable_L to W2 _ _. Jg: case Jg. search.
			W: apply jExt_wfj to Jg _.
			T: case T. case T2. T: apply jExt_tmSizel to _ Jg _.
			case J. case J2. J: apply jExt_m_judge to _ Jg _.
			Jg: case Jg1.
			% ||_forall = ||_tb = 0
				O: case O. O: case O. apply order_det to Jg1 *O3. case O. case O4. case O2.
				TB: case TB. TB: case TB. applys nTopBot_det Jg2 *TB3. case TB.
					case TB4. case TB2.
				apply nVar_det to V *Jg3. IV: case IV.
				O: apply jExt_orderl to _ Jg _. TB: applys jExt_nTB Jg.
				D: apply depthl_total_nat to W3.
				Jg: applys IH4 D1. backchain equivJ_decidable.
			% ||_forall decrease by 1, and ||_tb not changed
				O: case O. O: case O. apply order_det to Jg4 *O3. case O. case O4. P: case O2.
					IO: case IO. O: apply jExt_orderl to _ Jg _.
				TB: case TB. TB: case TB. applys nTopBot_det Jg2 *TB3. case TB. case TB4.
					TB: applys jExt_nTB Jg. TB: applys nTB_append Jg1 Jg3 TB.
				O: apply orderl_append to _ _ Jg1 _.
				TI: apply subExp_tmSizel_z to Jg6. DI: apply subExp_m_judge_z to Jg6.
				T: apply tmSizel_append to _ T Jg1 _. J: apply m_judge_append to _ J Jg1 _.
				V: apply nVar_total_nat to Jg7. D: apply depthl_total_nat to Jg7.
				Jg: applys IH3 V2 D2. backchain equivJ_decidable.
			% ||_tb decreases
				TB: case TB. TB: case TB. applys nTopBot_det Jg2 *TB3. case TB. case TB4.
					TB: applys jExt_nTB Jg. N: applys nTB_is_nat Jg3.
					P: applys add_total N with n = N2 n1.
					TB: applys nTB_append Jg1 P.
				lt: applys add_ltm Jg4 TB2 P.
					ITB: case ITB. case ltTB.
					ltTB: applys lt_trans lt ltTB.
				TI: apply subExp_tmSizel_z to Jg5. DI: apply subExp_m_judge_z to Jg5.
				O: applys orderl_total_nat Jg6.
				T: apply tmSizel_append to _ T Jg1 _. J: apply m_judge_append to _ J Jg1 _.
				V: apply nVar_total_nat to Jg6. D: apply depthl_total_nat to Jg6.
				Jg: applys IH2 O2 V2 D2. backchain equivJ_decidable.

		Rinst: assert name B -> member (exvar B) E1 -> fresh_ty B A ->
			judge (j (subty A B) :: E1) \/ (judge (j (subty A B) :: E1) -> false).
			intros A M B. case A. case B.
			Jg: apply instantiation_decidable_R to W1 _ _. Jg: case Jg. search.
			W: apply jExt_wfj to Jg _.
			T: case T. case T2. T: apply jExt_tmSizel to _ Jg _.
			case J. case J2. J: apply jExt_m_judge to _ Jg _.
			Jg: case Jg1.
			% ||_forall = ||_tb = 0
				O: case O. O: case O. apply order_det to Jg1 *O. case O3. case O4. case O2.
				TB: case TB. TB: case TB. applys nTopBot_det Jg2 *TB. case TB3.
					case TB4. case TB2.
				apply nVar_det to V *Jg3. IV: case IV.
				O: apply jExt_orderl to _ Jg _. TB: applys jExt_nTB Jg.
				D: apply depthl_total_nat to W3.
				Jg: applys IH4 D1. backchain equivJ_decidable.
			% ||_forall decrease by 1, and ||_tb not changed
				O: case O. O: case O. apply order_det to Jg4 *O. case O3.
					apply add_z_eq to *O4. P: case O2.
					IO: case IO. O: apply jExt_orderl to _ Jg _.
				TB: case TB. TB: case TB. applys nTopBot_det Jg2 *TB.
					case TB3. applys add_z_eq *TB4.
					TB: applys jExt_nTB Jg. TB: applys nTB_append Jg1 Jg3.
				O: apply orderl_append to _ _ Jg1 _.
				TI: apply subExp_tmSizel_z to Jg6. DI: apply subExp_m_judge_z to Jg6.
				T: apply tmSizel_append to _ T Jg1 _. J: apply m_judge_append to _ J Jg1 _.
				V: apply nVar_total_nat to Jg7. D: apply depthl_total_nat to Jg7.
				Jg: applys IH3 V2 D2. backchain equivJ_decidable.
			% ||_tb decreases
				TB: case TB. TB: case TB. applys nTopBot_det Jg2 *TB.
					case TB3. applys add_z_eq *TB4.
					TB: applys jExt_nTB Jg. N: applys nTB_is_nat Jg3.
					P: applys add_total N with n = N2 n1.
					TB: applys nTB_append Jg1 P.
				lt: applys add_ltm Jg4 TB2 P.
					ITB: case ITB. case ltTB.
					ltTB: applys lt_trans lt ltTB.
				TI: apply subExp_tmSizel_z to Jg5. DI: apply subExp_m_judge_z to Jg5.
				O: applys orderl_total_nat Jg6.
				T: apply tmSizel_append to _ T Jg1 _. J: apply m_judge_append to _ J Jg1 _.
				V: apply nVar_total_nat to Jg6. D: apply depthl_total_nat to Jg6.
				Jg: applys IH2 O2 V2 D2. backchain equivJ_decidable.

		Lall: assert all_ A -> (B = top -> false) -> notAll_ B ->
				judge (j (subty A B) :: E1) \/ (judge (j (subty A B) :: E1) -> false).
			intros A B_Top NB. case A. clear IH2 IH4 IH5.
			O: case O. O: case O. O: case O. O: case O4. O: case O2. IO: case IO.
			TB: assert nTB (j (subty (A1 n1) B) :: exvar n1 :: E1) NTB.
				TB: case TB. TB: case TB. TB: case TB. search.
			W: apply wfta_open_exvar to _ W1. W: apply wfta_weaken_ex to W2.
			W: assert wfj (j (subty (A1 n1) B) :: exvar n1 :: E1).
			V: apply nVar_total_nat to W5. D: apply depthl_total_nat to W5.
			T: case T. case T2. J: case J. case J2.
			Jg: applys IH3 V2 D2. Jg: case Jg. W: case W1. search.
			W: case W2.
				right. intros. case H1. backchain Jg.
				applys B_Top.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				case NB. applys H1.

		LRall: assert all_ A -> all_ B -> judge (j (subty A B) :: E1) \/
				(judge (j (subty A B) :: E1) -> false).
			intros A B. case A. case B. clear IH2 IH4 IH5.
			O: case O. O: case O. O: case O. O: case O3.
				P: apply add_s_inv to *O4. P: case P.
				P: case O2. P: case P1.
				IO: case IO. IO: case IO.
			TB: assert nTB (j (subty (A1 n1) (A2 n1)) :: styvar n1 :: E1) NTB.
				TB: case TB. TB: case TB.
				TB: case TB. TB: case TB3. search.
			W: case W1. W: case W2.
			W: applys wfta_ty_sty W1. W: applys wfta_ty_sty W2.
			W: assert wfj (j (subty (A1 n1) (A2 n1)) :: styvar n1 :: E1).
			V: apply nVar_total_nat to W7. D: apply depthl_total_nat to W7.
			T: case T. case T2. J: case J. case J2.
			Jg: applys IH3 V2 D2. Jg: case Jg. search.
				right. intros. case H1. applys notAll_false. backchain Jg.

		LBot: assert A = bot -> judge (j (subty A B) :: E1) \/
				(judge (j (subty A B) :: E1) -> false).
			intros A. case A. clear IH3 IH4 IH5.
			TB: case TB. N: applys add_is_nat_k TB2. backchain nTB_is_nat.
				TB: case TB. case TB. P: case TB4. P: case TB2.
				N: case N. lt: applys add_le P1.
				ltTB: applys lt_sm *ltTB.
				ITB: case ITB.
				lt: applys le_trans lt1. clear N lt lt1.
			T: case T. case T2. J: case J. case J2.
			O: applys orderl_total_nat W. V: applys nVar_total_nat W. D: applys depthl_total_nat W.
			Jg: applys IH2 _ lt2 O2 V2 D2. Jg: case Jg. search.
				right. intros. case H1. backchain Jg. backchain Jg. % applys H2.
		RTop: assert B = top -> judge (j (subty A B) :: E1) \/
				(judge (j (subty A B) :: E1) -> false).
			intros B. case B. clear IH3 IH4 IH5.
			TB: case TB. N: applys add_is_nat_k TB2. backchain nTB_is_nat.
				TB: case TB. case TB3. P: applys add_comm *TB4. P: case P. P: case TB2.
				N: case N. lt: applys add_le P1.
				ltTB: applys lt_sm *ltTB.
				ITB: case ITB.
				lt: applys le_trans lt1. clear N lt lt1.
			T: case T. case T2. J: case J. case J2.
			O: applys orderl_total_nat W. V: applys nVar_total_nat W. D: applys depthl_total_nat W.
			Jg: applys IH2 _ lt2 O2 V2 D2. Jg: case Jg. search.
				right. intros. case H1. backchain Jg. backchain Jg. backchain H4.

		Rall: assert all_ B -> judge (j (subty A B) :: E1) \/
				(judge (j (subty A B) :: E1) -> false).
			intros B. case B.
			W: case W1; try solve (right; intros f; case f).
				backchain LBot.
				backchain LRall.

		W: case W1.
			% A = 1
			clear Linst. W: case W2 (keep).
				% B = 1.
				O: case O. O: case O. case O. case O3. case O4. case O2.
					TB: case TB. TB: case TB. case TB. case TB3. case TB4. case TB2.
					D: case D. D: case D. case D. case D3. case D4. case D2. ID: case ID.
					J: case J. case J2. T: case T. case T2.
					Jg: applys IH5. Jg: case Jg. search.
						right. intros. case H1. backchain Jg.
				% B = top
				backchain RTop.
				% B = bot
				right. intros. case H1.
				% B = a
				right. intros. case H1. case H2.
					apply wfj_tyvar_exvar to W _ _. backchain append_mem.
				% B = ~a
				right. intros. case H1. case H2.
					apply wfj_styvar_exvar to W _ _. backchain append_mem.
				% B = ^a
				backchain Rinst.
				% B = A1 -> B1
				right. intros. case H1.
				% B = \forall x. A1
				backchain Rall.
			% A = top
			W: case W2.
				right. intros. case H1.
				backchain RTop.
				right. intros. case H1.
				right. intros. case H1.
				right. intros. case H1.
				right. intros. case H1.
				right. intros. case H1.
				backchain Rall.
			% A = bot
			backchain LBot.
			% A = a
			clear Linst. W: case W2 (keep).
				% B = 1
				right. intros. case H1. case H2.
					apply wfj_tyvar_exvar to W _ _. backchain append_mem.
				% B = top
				backchain RTop.
				% B = bot
				right. intros. case H1.
				% B = b
				right. intros. case H1.
					case H2. apply wfj_tyvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_tyvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_tyvar_exvar to W _ _ with X = n2. backchain split3_mem.
					case H2. apply wfj_tyvar_exvar to W _ _. backchain split3_mem.
				% B = a
				O: case O. O: case O. case O. case O3. case O4. case O2.
					TB: case TB. TB: case TB. case TB. case TB3. case TB4. case TB2.
					D: case D. D: case D. case D. case D3. case D4. case D2. ID: case ID.
					J: case J. case J2. T: case T. case T2.
					Jg: applys IH5. Jg: case Jg. search.
						right. intros. case H1.
							backchain Jg.
							applys wfj_tyvar_styvar W.
							apply wfj_tyvar_exvar to W _ _.
				% B = b
				right. intros. case H1.
					case H2. apply wfj_styvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_styvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_styvar_exvar to W _ _ with X = n2. backchain split3_mem.
					case H2. apply wfj_tyvar_styvar to W _ _. backchain split3_mem.
				% B = a
				applys wfj_tyvar_styvar W.
				% B = ^b
				backchain Rinst.
				% B = ^a
				apply wfj_tyvar_exvar to W _ _.
				% B = A1 -> B1
				right. intros. case H1. case H2.
					apply wfj_tyvar_exvar to W _ _. backchain append_mem.
				% B = \forall x. A1
				backchain Rall.
			% A = ~a
			clear Linst. W: case W2 (keep).
				% B = 1
				right. intros. case H1. case H2.
					apply wfj_styvar_exvar to W _ _. backchain append_mem.
				% B = top
				backchain RTop.
				% B = bot
				right. intros. case H1.
				% B = b
				right. intros. case H1.
					case H2. apply wfj_styvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_styvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_tyvar_exvar to W _ _ with X = n2. backchain split3_mem.
					case H2. apply wfj_styvar_exvar to W _ _. backchain split3_mem.
				% B = a
				applys wfj_tyvar_styvar W.
				% B = ~b
				right. intros. case H1.
					case H2. apply wfj_styvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_styvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_styvar_exvar to W _ _ with X = n2. backchain split3_mem.
					case H2. apply wfj_tyvar_styvar to W _ _ with X = n2. backchain split3_mem.
				% B = ~a
				O: case O. O: case O. case O. case O3. case O4. case O2.
					TB: case TB. TB: case TB. case TB. case TB3. case TB4. case TB2.
					D: case D. D: case D. case D. case D3. case D4. case D2. ID: case ID.
					J: case J. case J2. T: case T. case T2.
					Jg: applys IH5. Jg: case Jg. search.
						right. intros. case H1.
							applys wfj_tyvar_styvar W.
							backchain Jg.
							apply wfj_styvar_exvar to W _ _.
				% B = ^b
				backchain Rinst.
				% B = ^a
				apply wfj_styvar_exvar to W _ _.
				% B = A1 -> B1
				right. intros. case H1. case H2.
					apply wfj_styvar_exvar to W _ _. backchain append_mem.
				% B = \forall x. A1
				backchain Rall.
			% A = ^a
			W: case W2 (keep).
				% B = 1, top, bot or b
				backchain Linst. backchain Linst. backchain Linst. backchain Linst.
				% B = a
				apply wfj_tyvar_exvar to W _ _.
				% B = ~b
				backchain Linst.
				% B = ~a
				applys wfj_styvar_exvar W.
				% B = ^b
				backchain Linst.
				% B = ^a
				O: case O. O: case O. case O. case O3. case O4. case O2.
					TB: case TB. TB: case TB. case TB. case TB3. case TB4. case TB2.
					D: case D. D: case D. case D. case D3. case D4. case D2. ID: case ID.
					J: case J. case J2. T: case T. case T2.
					Jg: applys IH5. Jg: case Jg.
					search. right. intros. case H1.
						apply wfj_tyvar_exvar to W _ _.
						apply wfj_styvar_exvar to W _ _.
						backchain Jg.
				% B = A1 -> B1
				Fv: apply fv_decidable to W2. Fv: case Fv. backchain Linst.
					right. intros Jg. case Jg. backchain Fv.
				% B = \forall x. A1
				backchain Rall.
			% A = A1 -> B1
			W: case W2 (keep).
				% B = 1
				right. intros. case H1.
				% B = top
				backchain RTop.
				% B = bot
				right. intros. case H1.
				% B = a
				right. intros. case H1. case H2.
					apply wfj_tyvar_exvar to W _ _. backchain append_mem.
				% B = ~a
				right. intros. case H1. case H2.
					apply wfj_styvar_exvar to W _ _. backchain append_mem.
				% B = ^a
				Fv: apply fv_decidable to _ with A = x\ arrow (A1 x) (B1 x).
					Fv: case Fv. backchain Rinst.
					right. intros Jg. case Jg. backchain Fv.
				% B = A2 -> B2
				O: case O. O: case O. O: case O. O: case O3. P: apply add_assoc4 to O6 O8 _.
					TB: assert nTB (j (subty A2 A1) :: j (subty B1 B2) :: E1) NTB.
						TB: case TB. TB: case TB. TB: case TB. TB: case TB3.
						P: applys add_assoc4 TB6 TB8.
						P: applys add_assoc P5. search.
					D: case D. D: case D. D: case D. D: case D3. P: case D4.
					P: apply add_s_inv to *P3. P: case D2. P: case P4.
					P: apply add_assoc4 to D6 D8 _. ID: case ID.
					W: assert wfj (j (subty A2 A1) :: j (subty B1 B2) :: E1).
						apply wfta_weaken_j to W4 with J = subty B1 B2.
						apply wfta_weaken_j to W1 with J = subty B1 B2. search.
					J: case J. case J2. T: case T. case T2.
					Jg: applys IH5 W6 _ ltTB.
						P: apply add_s to P7. P: apply add_assoc to P7 P4.
						P: apply add_s to P10. search.
						O: apply add_assoc to P2 O2. search.
					Jg: case Jg. search. right. intros. case H1. backchain Jg.
				% B = \forall x. A
				backchain Rall.
			% A = \forall x. A1
			W: case W2.
				backchain Lall.
				backchain RTop.
				backchain Lall.
				backchain Lall.
				backchain Lall.
				backchain Lall.
				backchain Lall.
				backchain Rall.
	% E, e <== A
	T: case T. T: case T. J: case J. J: case J. P: case J2. P: case P. P: case P.
		O: case O. O: case O. TB: case TB. case TB. case TB2. V: case V.
		chkSub: assert (A = top -> false) -> notLam_ X -> notAll_ A ->
				judge (j (check X A) :: E1) \/ (judge (j (check X A) :: E1) -> false).
			W: apply wfta_weaken_ty to W2. % ^a for now
			W: assert wfj (j (inferC X (a\subty a A)) :: E1).
			IJ: case IJ. D: apply depthl_total_nat to W4.
			N: apply tmSize_is_nat to T. P: apply add_zero to N.
			Jg: applys IH1 W4 ITB IO IV D2. Jg: case Jg. search.
				intros. right. intros. case H4.
					F: case H3. apply F to _.
					F: case H2. apply F to _.
					F: case H2. apply F to _.
					backchain Jg.
					applys H1.
		W: case W2.
			% A = i
			W: case W1.
				case T. T: case T2. case T. case O. case O2.
					D: case D. D: case D. case D. case D2. ID: case ID.
					IJ: case IJ. IJ: case IJ. ltT: applys lt_sm *ltT. IT: case IT.
					Jg: applys IH1 W ITB IO IV ID. Jg: case Jg. search.
						right. intros Jg. Jg: case Jg1. Jg: case Jg4. Jg: case Jg4. backchain Jg.
				backchain chkSub.
				right. intros. case H1. F: case H4. apply F to _.
				backchain chkSub. backchain chkSub. backchain chkSub. backchain chkSub.
			% A = top
			IJ: case IJ. IJ: case IJ. case O. case O2.
				V: applys nVar_total_nat W. D: applys depthl_total_nat W.
				Jg: assert judge E1 \/ (judge E1 -> false).
					NT: applys tmSize_is_nat T. NT: case NT.
						case T2. Jg: applys IH1 W IT ITB IO V2 D2. search.
						P: case T2. ltT: applys lt_sm *ltT.
							N: applys tmSizel_is_nat. N: applys add_is_nat_k P.
							IT: case IT. lt: applys add_le P. lt: applys le_trans lt1.
							Jg: applys IH W IJ IT lt2 ITB IO V2 D2. search.
				Jg: case Jg. search.
					right. intros. case H1. applys H2.
					backchain Jg.
			% A = bot
			W: case W1.
				backchain chkSub. backchain chkSub.
				right. intros. case H1. case H4.
					applys judge_inferLam_arrow_sub_bot_false.
				backchain chkSub. backchain chkSub. backchain chkSub. backchain chkSub.
			% A = a
			W: case W1.
				backchain chkSub. backchain chkSub.
				right. intros. case H1. case H2.
					apply append_mem to H4 _. apply wfj_tyvar_exvar to W _ _.
					F: case H4. apply F to _.
				backchain chkSub. backchain chkSub. backchain chkSub. backchain chkSub.
			% A = ~a
			W: case W1.
				backchain chkSub. backchain chkSub.
				right. intros. case H1. case H2.
					apply append_mem to H4 _. apply wfj_styvar_exvar to W _ _.
					F: case H4. apply F to _.
				backchain chkSub. backchain chkSub. backchain chkSub. backchain chkSub.
			% A = ^a
			W: case W1 (keep).
				backchain chkSub. backchain chkSub.
				clear W3. clear W4. T: case T. T: case T2. ltT: applys lt_sm *ltT. IT: case IT.
					A: apply single_append to W2. apply wfj_prune_exvar to _ A.
					W: apply wfj_insert_exvar_intro to A _.
					W: apply wftm_insert_exvar to A _ _ W1.
					W: assert wfj (j (check (X1 (arrow n1 n2) n3) n2) :: of n3 n1 :: FxyE n1 n2).
						W: apply wftm_anyA to W5 with A = n1.
						M: apply append_mem to W3 _. M: apply append_mem to W3 _ with X = exvar n1.
						search.
					Ext: apply jExt_inst to _ W3 _ with F = A2.
					T: apply tmSizel_total_wfj to W4. apply jExt_tmSizel_eq to _ Ext _ _.
					apply tmSize_prune to T.
					T: apply tmSize_subst to T with X = x\ X1 x n2, A = x\ arrow x n2, x = n1.
					T: assert tmSizel
						(j (check (X1 (arrow n1 n2) n3) n2) :: of n3 n1 :: FxyE n1 n2) (K2 n1).
					J: apply m_judge_total_wfj to W6. IJ: apply m_judge_is_nat to J.
					O: apply orderl_total_wfj to W6. IO: apply orderl_is_nat to O3.
					V: apply nVar_total to W6. IV: apply nVar_is_nat to V1.
					D: apply depthl_total to W6. ID: apply depthl_is_nat to D1.
					TB: applys nTB_total_nat W6. TB: assert is_nat (s (NE1 n2 n1 n3)).
					Jg: applys IH W6 IT IJ1 TB3 IO1 IV1 ID1. Jg: case Jg. search.
						right. intros. case H1. apply inst_det to H2 _ _ with G = FxyE. backchain Jg.
						F: case H4. apply F to _.
				backchain chkSub. backchain chkSub. backchain chkSub. backchain chkSub.
			% A = A1 -> B
			W: case W1 (keep).
				backchain chkSub. backchain chkSub.
				W: assert wfj (j (check (X1 n1) B) :: of n1 A1 :: E1).
					W: apply wftm_anyA to W1 with A = A1. W: apply wfta_weaken_of to W3 with A = A1.
					search.
					T: case T. T: case T2. ltT: applys lt_sm *ltT. IT: case IT.
					J: apply m_judge_total_wfj to W6. IJ: apply m_judge_is_nat to J.
					O: apply orderl_total_wfj to W6. IO: apply orderl_is_nat to O3.
					V: apply nVar_total to W6. IV: apply nVar_is_nat to V1.
					D: apply depthl_total to W6. ID: apply depthl_is_nat to D1.
					TB: applys nTB_total_nat W6. TB: assert is_nat (s (NE1 n1)).
					Jg: applys IH W6 IT IJ1 TB3 IO1 IV1 ID1. Jg: case Jg. search.
						right. intros. case H1. backchain Jg.
						F: case H4. apply F to _.
				backchain chkSub. backchain chkSub. backchain chkSub. backchain chkSub.
			% A = \forall x. A
			% W: case W1 (keep); try solve backchain chkSub.
			O: case O. O: case O2. IO: case IO.
				W: apply wftm_weaken_ty to W1.
				W: assert wfj (j (check X (A1 n1)) :: tyvar n1 :: E1).
				V: apply nVar_total to W5. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W5. ID: apply depthl_is_nat to D1.
				Jg: applys IH3 IV1 ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
					F: case H3. apply F to _.
	% E, e => w
	clear IH3. clear IH4. W: case W1.
		% () => 1
		W: apply wfjg_subst_tyvar to W2 _ _.
			T: case T. T: case T. T: case T. T: case T4. case T. T: case T2.
			ltT: applys lt_sm *ltT. IT: case IT.
			T: apply tmSizeJ_total to W1. T: apply tmSizeJ_subst_eq to T3 T2.
			W: assert wfj (j (J1 i) :: E1).
				J: apply m_judge_total_wfj to W3. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W3. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W3. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W3. ID: apply depthl_is_nat to D1.
				TB: applys nTB_total_nat W3. NTB: assert is_nat (s NE1).
				Jg: applys IH W3 IJ1 NTB IO1 IV1 ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% x => A
		W: apply wfj_of_wfta to _ W1.
			T: case T. apply nat_prune_tm to IT. apply add_prune[tm] to T2. T: case T.
			case T. T: case T4. case T. T: case T2.
			ltT: applys lt_sm *ltT. IT: case IT.
			W: apply wfjg_subst_tyvar to W2 _ _.
			T: apply tmSizeJ_total to W4. apply tmSizeJ_subst_eq to T3 T2.
			W: assert wfj (j (J1 n2 A) :: E1 n2).
				J: apply m_judge_total_wfj to W5. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W5. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W5. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W5. ID: apply depthl_is_nat to D1.
				TB: applys nTB_total_nat W5. NTB: assert is_nat (s (NE1 n2)).
				Jg: applys IH W5 IT IJ1 NTB IO1 IV1 ID1. Jg: case Jg. search.
					right. intros. case H1. apply wfj_of_det to _ W1 H2. backchain Jg.
		% \lambda x. X => ^a -> ^b
		W: apply wfjg_ty2ex to W2 _.
			W: apply wfjg_insert_exvar to _ _ _ W4 with E = E1, F = x\ nil.
			W: assert wfj (j (J1 (arrow n2 n3)) :: exvar n3 :: exvar n2 :: E1).
			W: apply wftm_weaken_f to _ _ with F = E1, T = lam X1,
				EF = j (J1 (arrow n2 n3)) :: exvar n3 :: exvar n2 :: E1.
			W: apply wftm_anyA to *W7 with A = n2.
			W: assert 6 wfj (j (check (X1 n1) n3) :: of n1 n2 :: j (J1 (arrow n2 n3)) ::
				exvar n3 :: exvar n2 :: E1).
			T: case T. T: case T. T: case T. P: case T4. P: case T2.
			ltT: applys lt_sm *ltT. IT: case IT.
			T: assert tmSizel (j (check (X1 n1) n3) :: of n1 n2 :: j (J1 (arrow n2 n3)) ::
					exvar n3 :: exvar n2 :: E1) K1.
				T: apply tmSizeJ_total to W5. permute (n1 n2) T2. apply tmSizeJ_subst_eq to T3 T2.
				P: apply add_assoc to P P1. search.
			J: apply m_judge_total_wfj to W8. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W8. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W8. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W8. ID: apply depthl_is_nat to D1.
				TB: applys nTB_total_nat W8. NTB: assert is_nat (s (NE1 n2 n3 n1)).
				Jg: applys IH W8 IT IJ1 NTB IO1 IV1 ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% X1 X2 => ...
		T: case T. T: case T. T: case T. P: case T4. P: case T2.
			ltT: applys lt_sm *ltT. IT: case IT.
			W: apply wftm_weaken_ty to W3.
			W: apply wfjg_weaken_tyvar_fresh to _ _ _ W2 with FxE = x\ tyvar n1 :: tyvar x :: E1.
			W: assert wfj (j (inferC X1 (a\ inferAppC a Y J1)) :: E1).
			P: apply add_assoc to T6 P.
			T: assert tmSizel (j (inferC X1 (a\ inferAppC a Y J1)) :: E1) K2.
				J: apply m_judge_total_wfj to W6. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W6. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W6. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W6. ID: apply depthl_is_nat to D1.
				TB: applys nTB_total_nat W6. NTB: assert is_nat (s NE1).
				Jg: applys IH W6 IT IJ1 NTB IO1 IV1 ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% (X : A) => A
		T: case T. T: case T. T: case T. P: case T4. P: case T2.
			ltT: applys lt_sm *ltT. IT: case IT.
			W: apply wfjg_subst_tyvar to W2 _ _.
			T: apply tmSizeJ_total to W4. apply tmSizeJ_subst_eq to T3 T2.
			P: apply add_assoc to P P1.
			W: apply wftm_weaken_j to W1 with J = J1 A.
			W: apply wfta_weaken_j to W3 with J = J1 A.
			W: assert wfj (j (check X1 A) :: j (J1 A) :: E1).
				J: apply m_judge_total_wfj to W7. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W7. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W7. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W7. ID: apply depthl_is_nat to D1.
				TB: applys nTB_total_nat W7. NTB: assert is_nat (s NE1).
				Jg: applys IH W7 IT IJ1 NTB IO1 IV1 ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% X @A => A
		T: case T. T: case T. T: case T. P: case T4. P: case T2.
			ltT: applys lt_sm *ltT. IT: case IT.
			W: apply wfjg_weaken_tyvar_fresh to _ _ _ W2 with FxE = x\ tyvar n1 :: tyvar x :: E1.
			W: applys wfta_weaken_ty W3.
			W: assert wfj (j (inferC X1 (a\ typeAppC a A J1)) :: E1).
			P: apply add_assoc to P P1.
			T: assert tmSizel (j (inferC X1 (a\ typeAppC a A J1)) :: E1) K1.
				J: apply m_judge_total_wfj to W6. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W6. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W6. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W6. ID: apply depthl_is_nat to D1.
				TB: applys nTB_total_nat W6. NTB: assert is_nat (s NE1).
				Jg: applys IH W6 IT IJ1 NTB IO1 IV1 ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% /\a. e : A => \forall a. A
		T: case T. T: case T. T: case T. P: case T4. P: case T2.
			ltT: applys lt_sm *ltT. IT: case IT.
			W: applys wfjg_subst_tyvar with A = all A.
			W: assert wftm E1 (tAnno X1 A).
			W: applys wftm_weaken_j W5 with J = J1 (all A).
			W: case W6. W: case W7.
			W: assert wfj (j (check (X1 n1) (A n1)) :: tyvar n1 :: j (J1 (all A)) :: E1).
			P: apply add_assoc to P P1.
			T: applys tmSizeJ_total W4. T: applys tmSizeJ_subst_eq T3 T2.
			T: assert tmSizel (j (check (X1 n1) (A n1)) :: tyvar n1 :: j (J1 (all A)) :: E1) K1.
				J: apply m_judge_total_wfj to W9. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W9. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W9. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W9. ID: apply depthl_is_nat to D1.
				TB: applys nTB_total_nat W9. NTB: assert is_nat (s (NE1 n1)).
				Jg: applys IH W9 IT IJ1 NTB IO1 IV1 ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
	% E, A ` e =>> w
	clear IH4 IH5. W: case W2.
		% A = i
		right. intros. case H1.
		% A = top
		right. intros. case H1.
		% A = bot
			T: case T. T: case T. P: apply add_assoc to T4 T2.
			J: case J. J: case J. P: case J2. P: case P2. P: case P2.
			IJ: case IJ. IJ: case IJ. IJ: case IJ.
			W: apply wftm_weaken_j to _ with J = J1 bot.
			W: applys wfjg_subst_tyvar W3 with A = bot.
			T: apply tmSizeJ_total to W4. apply tmSizeJ_subst_eq to T3 T5.
			N: applys add_is_nat_k T2. backchain tmSizel_is_nat.
			ltT: applys add_le P1. ltT: applys le_trans ltT2.
			J: apply m_judgeJ_total_wfjg to W4. apply m_judgeJ_subst_eq to J J2.
			W: assert wfj (j (J1 bot) :: E1).
			TB: applys nTB_total_nat W5. TBN: assert is_nat (s NE).
			O: applys orderl_total_nat W5.
			V: applys nVar_total_nat W5.
			D: applys depthl_total_nat to W5.
			Jg: applys IH1 W5 ltT3 IJ TBN O2 V2 D2. Jg: case Jg. search.
				right. intros. case H1. backchain Jg.
		% A = a
		right. intros. case H1. case H2. apply append_mem to H4 _.
			apply wfj_tyvar_exvar to W _ _.
		% A = ~a
		right. intros. case H1. case H2. apply append_mem to H4 _.
			apply wfj_styvar_exvar to W _ _.
		% A = ^a
		A: apply single_append to W2. apply wfj_prune_exvar to _ A.
			A: apply wfj_insert_exvar_intro to A _.
			W: apply wfjg_insert_exvar to _ _ _ W3 with F = x\ tyvar n1 :: A1 x.
			W: apply wftm_insert_exvar to _ _ _ W1 with F = A1.
			M: apply append_mem to A1 _. M: apply append_mem to A1 _ with X = exvar n1.
			W: apply wftm_weaken_j to W5 with J = J1 (arrow n2 n3) n3.
			W: apply wfjg_subst_tyvar to W4 _ _ with A = n4.
			Ext: apply jExt_inst to _ _ _ with F = A1.
			apply nat_prune_ty to IT. applys tmSizel_prune T.
			T: assert tmSizel (j (check (X (arrow n1 n2)) n1) ::
					j (J1 (arrow n1 n2) n2) :: FxyE n1 n2) Nr1.
				T: case T. apply add_prune[ty] to T2.
				T: apply jExt_tmSizel to _ Ext _.
				T: case T. apply add_prune[ty] to T5.
				T: apply tmSizeJ_total to W7.
				N: apply tmSizeJ_is_nat to T6. apply nat_prune_ty to N. apply nat_prune_ty to *N.
				apply tmSizeJ_subst_eq to T4 _ with A = x\ arrow x n1.
				P: apply add_assoc to T5 T2.
				T: apply tmSize_subst to T with A = arrow n1.
				search.
			apply nat_prune_ty to IJ. J: case J. J: case J. J: case J2. IJ: case IJ.
			J: assert m_judge (j (check (X (arrow n1 n2)) n1) ::
					j (J1 (arrow n1 n2) n2) :: FxyE n1 n2) Nr3.
				P: case J2. P: case P. apply add_prune[ty] to P.
				J: apply jExt_m_judge to _ Ext _.
				J: apply m_judgeJ_total_wfjg to W7.
				N: apply m_judgeJ_is_nat to J3. apply nat_prune_ty to N. apply nat_prune_ty to *N.
				apply m_judgeJ_subst_eq to J _ with A = x\ arrow x n1.
				search.
			W: assert wfj (j (check (X (arrow n1 n2)) n1) ::
					j (J1 (arrow n1 n2) n2) :: FxyE n1 n2).
				TB: applys nTB_total_nat W8. TBN: assert is_nat (s (NE n2 n1)).
				O: applys orderl_total_nat W8.
				V: applys nVar_total_nat W8.
				D: applys depthl_total_nat W8.
				Jg: applys IH1 W8 IT IJ TBN O2 V2 D2. Jg: case Jg. search.
					right. intros. case H1. case H3.
					assert instJs E1 FxyE. apply inst_det to H2 *H5 _. backchain Jg.
		% A = A1 -> B
			T: case T. T: case T. P: apply add_assoc to T4 T2.
			J: case J. J: case J. P: case J2. P: case P2. P: case P2. IJ: case IJ.
			W: apply wftm_weaken_j to _ with J = J1 B. W: apply wfta_weaken_j to W2 with J = J1 B.
			W: apply wfjg_subst_tyvar to W3 W4 _.
			T: apply tmSizeJ_total to W7. apply tmSizeJ_subst_eq to T3 T5.
			J: apply m_judgeJ_total_wfjg to W7. apply m_judgeJ_subst_eq to J J2.
			W: assert wfj (j (check X A1) :: j (J1 B) :: E1).
				TB: applys nTB_total_nat W8. TBN: assert is_nat (s NE).
				O: applys orderl_total_nat W8.
				V: applys nVar_total_nat W8.
				D: applys depthl_total_nat W8.
				Jg: applys IH1 W8 IT IJ TBN O2 V2 D2. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% A = \forall x. A
			T: case T. T: case T.
			J: case J. J: case J. P: case J2. P: case P. P: case P.
			O: case O. O: case O. O: case O.
				P: case O4. P: case O2. apply add_prune[ty] to P1. IO: case IO.
			TB: case TB. TB: case TB. case TB2.
			T: assert tmSizel (j (inferAppC (A1 n1) X J1) :: exvar n1 :: E1) NT.
			J: assert m_judge (j (inferAppC (A1 n1) X J1) :: exvar n1 :: E1) (s (s (s K2))).
			O: assert orderl (j (inferAppC (A1 n1) X J1) :: exvar n1 :: E1) K4.
			W: assert wfj (j (inferAppC (A1 n1) X J1) :: exvar n1 :: E1).
				W: apply wftm_weaken_ex to _.
				W: apply wfta_open_exvar to _ _.
				W: apply wfjg_insert_exvar_raw to _ _ _ W3 with FxE = x\ tyvar n1 :: exvar x :: E1.
				search.
			V: apply nVar_total to W5. IV: apply nVar_is_nat to V1.
			D: apply depthl_total to W5. ID: apply depthl_is_nat to D1.
			Jg: applys IH3 IO IV1 ID1. Jg: case Jg. search.
				right. intros. case H1. backchain Jg.
	% E, A @B =>> w
	clear IH2 IH3 IH4 IH5. W: case W1.
		right. intros. case H1.
		right. intros. case H1.
		% bot
		W: applys wfjg_subst_tyvar W3 with A = bot.
			T: case T. T: case T.
			T: applys tmSizeJ_total W1.
			T: applys tmSizeJ_subst_eq T with A = x\ bot.
			T: assert tmSizel (j (J1 bot) :: E1) NT.
			J: case J. J: case J. P: case J2.
			J: applys m_judgeJ_total_wfjg W1.
			J: applys m_judgeJ_subst_eq J with A = x\ bot.
			IJ: case IJ.
			J: assert m_judge (j (J1 bot) :: E1) K.
			W: assert wfj (j (J1 bot) :: E1).
				TB: applys nTB_total_nat W4. TBN: assert is_nat (s NE).
				O: applys orderl_total_nat W4.
				V: applys nVar_total_nat W4.
				D: applys depthl_total_nat W4.
				Jg: applys IH1 W4 IT IJ TBN O2 V2 D2. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		right. intros. case H1.
		right. intros. case H1.
		right. intros. case H1.
		right. intros. case H1.
		% (forall a. A) @B
		W: applys wfta_subst_tyvar W1 W2.
			W: applys wfjg_subst_tyvar W3 with A = A1 B.
			T: case T. T: case T.
			T: applys tmSizeJ_total W6.
			T: applys tmSizeJ_subst_eq T with A = x\ A1 B.
			T: assert tmSizel (j (J1 (A1 B)) :: E1) NT.
			J: case J. J: case J. P: case J2.
			J: applys m_judgeJ_total_wfjg W6.
			J: applys m_judgeJ_subst_eq J with A = x\ A1 B.
			IJ: case IJ.
			J: assert m_judge (j (J1 (A1 B)) :: E1) K.
			W: assert wfj (j (J1 (A1 B)) :: E1).
				TB: applys nTB_total_nat W7. TBN: assert is_nat (s NE).
				O: applys orderl_total_nat W7.
				V: applys nVar_total_nat W7.
				D: applys depthl_total_nat W7.
				Jg: applys IH1 W7 IT IJ TBN O2 V2 D2. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.



Theorem decidable : forall E, wfj E -> judge E \/ (judge E -> false).
intros W.
	T: applys tmSizel_total_nat W. NT: assert is_nat (s NE).
	J: applys m_judge_total_nat W.
	TB: applys nTB_total_nat W. NTB: assert is_nat (s NE2).
	O: applys orderl_total_nat W.
	V: applys nVar_total_nat W.
	D: applys depthl_total_nat W.
	applys decidable_thm NT J1 NTB O1 V1 D1.
	search.

Theorem decidable_decl : forall E, wfj E -> exFree E -> dc E \/ (dc E -> false).
intros.
	Jg: apply decidable to H1. Jg: case Jg.
	left. apply soundness to _ _. T: case H3. search.
		apply append_mem to T _. apply exFree_false to H5 _.
	right. intros D. T: assert tex E E.
		E: apply tex_exFree to T _.
		apply dcl_complete to H1 _ _.
		apply completeness to _ _ _.
		backchain Jg.

