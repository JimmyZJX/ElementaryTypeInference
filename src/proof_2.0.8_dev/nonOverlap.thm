Import "trans".

Theorem mono_strenthen_tyvar : forall F E FE FxE A T, nabla x,
	append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
	mono (FxE x) T -> mono E A -> mono (FE A) T.
induction on 3. intros. case H3.
	search.
	assert member (tyvar n2) (FE n2 n1).
			apply append_mem_inv to H2 H5. case H6. backchain append_mem.
			case H7. backchain append_mem.
		apply mem_tyvar_subst to H6 with A = A. search.
	apply IH to H1 H2 H5 _. apply IH to H1 H2 H6 _. search.

Theorem mono_strenthen_tyvar_notfresh : forall F E FE FxE A T, nabla x,
	append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
	mono (FxE x) (T x) -> mono E A -> mono (FE A) (T A).
induction on 3. intros. case H3.
	search.
	assert member (tyvar n2) (FE n2 n1).
			apply append_mem_inv to H2 H5. case H6. backchain append_mem.
			case H7. backchain append_mem.
		apply mem_tyvar_subst to H6 with A = A. search.
	W: apply mono_wfta to H4.
		A: apply append_subst to H1 with A = A.
		W: apply mono_weaken_f to A _. search.
	apply IH to H1 H2 H5 _. apply IH to H1 H2 H6 _. search.

Theorem mono_nil_any : forall E m, mono nil m -> mono E m.
induction on 1. intros. case H1. % Manual Fix
	search. case H2. unfold. backchain IH. backchain IH.

Theorem sub_tyvar_notall : forall E A, nabla x, % E0 does not have x
	sub (E x) (all (A x)) x -> member (styvar x) (E x) -> wfj (E x) -> false.
induction on 1. intros S Sty. S: case S (keep).
	apply mono_prune_styvar to _ Sty _. /* GEN_BY_SCRIPT 
	applys mono_prune_styvar Sty. */ 
		W: apply sub_wft to S1. /* GEN_BY_SCRIPT 
		W: applys sub_wft S1. */ 
		S: case S1 (keep).
			case S5. f: case S4. backchain f. case S2.
			case S5. f: case S4. backchain f. case S2.
			case S5. f: case S4. backchain f.
			case S5. f: case S4. backchain f.
			case S5. f: case S4. backchain f.
			apply mono_prune_styvar to _ _ S7. /* GEN_BY_SCRIPT 
			applys mono_prune_styvar S7. */ 
				case S5.
					apply IH to S1 _ _ with A = x\ A2 x M. /* GEN_BY_SCRIPT 
					applys IH S1 with A = x\ A2 x M. */ 
					apply IH to S1 _ _. /* GEN_BY_SCRIPT 
					applys IH S1. */ 


Theorem sub_subst_wft : forall E A B C, nabla x,
	wft (E x) C -> sub (E x) (A x) (B x) -> member (styvar x) (E x) -> wfj (E x) ->
	sub (E x) (A C) (B C).
induction on 2. intros W S Sty. S: case S (keep).
	search.
	W: apply wft_subst to S1 W with T = A. /* GEN_BY_SCRIPT 
	W: applys wft_subst S1 W with T = A. */  search.
	W: apply wft_subst to S1 W with T = B. /* GEN_BY_SCRIPT 
	W: applys wft_subst S1 W with T = B. */  search.
	search.
	backchain sub_refl.
	search.
	backchain sub_refl.
	S: apply IH to _ S1 _ _. /* GEN_BY_SCRIPT 
	S: applys IH S1. */  S: apply IH to _ S2 _ _. /* GEN_BY_SCRIPT  S: applys IH S2. */  search.
	apply mono_prune_styvar to _ _ S2. /* GEN_BY_SCRIPT 
	applys mono_prune_styvar S2. */ 
		notAll: assert notAll_ (B C) \/ B = x\ x.
			W: apply sub_wft to S1. /* GEN_BY_SCRIPT 
			W: applys sub_wft S1. */ 
			W: case W2. % Manual Fix   try search. apply notAll_false to S3. /* GEN_BY_SCRIPT  applys notAll_false S3. */ 
			search. search. search. search. search. search. search. search. apply notAll_false to S3.
		S: apply IH to _ S1 _ _. /* GEN_BY_SCRIPT 
		S: applys IH. */ 
		All: case notAll.
			W: apply sub_wft to S. /* GEN_BY_SCRIPT 
			W: applys sub_wft S. */  W: case W1.
				FV: apply inFV_subst to W1 _ with A = A1, m = C. /* GEN_BY_SCRIPT 
				FV: applys inFV_subst W1 with A = A1, m = C. */ 
				unfold. exists M.
				search.
			apply sub_tyvar_notall to S _ _. /* GEN_BY_SCRIPT 
			applys sub_tyvar_notall S. */ 
	W: apply wft_weaken_f to _ W with E = styvar n2 :: nil. /* GEN_BY_SCRIPT 
	W: applys wft_weaken_f W with E = styvar n2 :: nil. */ 
		S: apply IH to W1 S1 _ _ with x = n1. /* GEN_BY_SCRIPT 
		S: applys IH W1 with x = n1. */ 
		W: apply sub_wft to S1. /* GEN_BY_SCRIPT 
		W: applys sub_wft S1. */ 
		FV: apply inFV_subst to W2 _ with A = A1, m = C. /* GEN_BY_SCRIPT 
		FV: applys inFV_subst W2 with A = A1, m = C. */ 
		FV: apply inFV_subst to W3 _ with A = B1, m = C. /* GEN_BY_SCRIPT 
		FV: applys inFV_subst W3 with A = B1, m = C. */ 
		search.

Theorem mid_ty_det : forall F E FxE F' E', nabla (x : ty),
	append (F x) (tyvar x :: E) (FxE x) -> append (F' x) (tyvar x :: E') (FxE x) ->
	F = F' /\ E = E'.
induction on 1. intros. case H1. % Manual Fix
case H2.
	search. apply append_prune to H3. /* GEN_BY_SCRIPT  applys append_prune H3. */ 
case H2.
	apply append_prune to H3. /* GEN_BY_SCRIPT 
	applys append_prune H3. */ 
	apply IH to H3 H4. /* GEN_BY_SCRIPT 
	applys IH H4. */  search.


Theorem sub_substM : forall F E FxE FE A B m, nabla x,
	append (F x) (tyvar x :: E) (FxE x) -> append (F x) E (FE x) ->
	mono E m -> sub (FxE x) (A x) (B x) -> sub (FE m) (A m) (B m).
induction on 4. intros A A M S SE a. S: case S (keep).
	search.
	W: apply mono_wft to M. /* GEN_BY_SCRIPT 
	W: applys mono_wft M. */ 
		W: apply wft_strenthen_tyvar_notfresh to A1 A S1 W. /* GEN_BY_SCRIPT 
		W: applys wft_strenthen_tyvar_notfresh A1 A S1 W. */ 
		search.
	W: apply mono_wft to M. /* GEN_BY_SCRIPT 
	W: applys mono_wft M. */ 
		W: apply wft_strenthen_tyvar_notfresh to A1 A S1 W. /* GEN_BY_SCRIPT 
		W: applys wft_strenthen_tyvar_notfresh A1 A S1 W. */ 
		search.
	M: apply mem_FxE_FE to A _ _ _. /* GEN_BY_SCRIPT 
	M: applys mem_FxE_FE A. */ 
		M: apply mem_tyvar_subst to M1 with A = m. /* GEN_BY_SCRIPT 
		M: applys mem_tyvar_subst M1 with A = m. */ 
		search.
	A: apply append_subst to A1 with A = m. /* GEN_BY_SCRIPT 
	A: applys append_subst A1 with A = m. */ 
		M: apply mono_weaken_f to A2 _. /* GEN_BY_SCRIPT 
		M: applys mono_weaken_f A2. */ 
		W: apply mono_wfta to M. /* GEN_BY_SCRIPT 
		W: applys mono_wfta M. */ 
		backchain sub_refl. backchain mono_wft.
	M: apply mem_FxE_FE to A _ _ _. /* GEN_BY_SCRIPT 
	M: applys mem_FxE_FE A. */ 
		W: apply mem_styvar_subst to M1 with A = m. /* GEN_BY_SCRIPT 
		W: applys mem_styvar_subst M1 with A = m. */ 
		search.
	backchain sub_refl. backchain mono_wft.
		A: apply append_subst to A1 with A = m. /* GEN_BY_SCRIPT 
		A: applys append_subst A1 with A = m. */ 
		backchain mono_weaken_f.
	S: apply IH to _ _ _ S1. /* GEN_BY_SCRIPT 
	S: applys IH S1. */  S: apply IH to _ _ _ S2. /* GEN_BY_SCRIPT  S: applys IH S2. */  search.
	S: apply IH to _ _ _ S1. /* GEN_BY_SCRIPT 
	S: applys IH. */ 
		M: apply mono_strenthen_tyvar_notfresh to _ _ S2 M. /* GEN_BY_SCRIPT 
		M: applys mono_strenthen_tyvar_notfresh S2 M. */ 
		W: apply sub_wft to S. /* GEN_BY_SCRIPT 
		W: applys sub_wft S. */ 
		unfold. exists m1 m. split. % Manual Fix try search.
		search. search.
			case W1. % Manual Fix
				search. search. search. search.
				case M. search. search.
				search.
				search.
				case M. search. search. search.
				case M. search. search. search.
				apply notAll_false to S3.
			W: case W. inFV: apply inFV_subst to _ W2 with A = A1, m = m. /* GEN_BY_SCRIPT  inFV: applys inFV_subst W2 with A = A1, m = m. */  search.
	A: assert append (styvar n2 :: F n1) (tyvar n1 :: E) (styvar n2 :: FxE n1).
		S: apply IH to A2 _ _ S1. /* GEN_BY_SCRIPT 
		S: applys IH A2. */ 
		W: apply sub_wft to S. /* GEN_BY_SCRIPT 
		W: applys sub_wft S. */  W: case W. W: case W1.
		FV: apply inFV_subst to _ W2 with A = A1, m = m. /* GEN_BY_SCRIPT 
		FV: applys inFV_subst W2 with A = A1, m = m. */ 
		FV: apply inFV_subst to _ W3 with A = B1, m = m. /* GEN_BY_SCRIPT 
		FV: applys inFV_subst W3 with A = B1, m = m. */ 
		search.


Theorem wft_open_free : forall E (A : ty -> ty -> ty) m Ar, nabla x,
	wft (E x) (A x (m x)) -> mono (E x) (m x) ->
		A x (m x) = Ar -> exists A', A = x\ m\ A' m.
induction on 1. intros. Aux: assert forall (A : ty) B, A = B -> B = A. case H1.
	case H4. search. search.
	case H4. search. search.
	case H4. search. search.
	case H4. search. search.
	case H4. case H3. search.
	case H4. search. search.
	case H4. case H3. search.
	case H4. Eq: case H3.
		Eq: apply Aux to Eq. Eq: apply Aux to Eq1.
			apply IH to H5 _ _ with A = A2.
			apply IH to H6 _ _ with A = A3.
			search.
		search.
	case H4. Eq: case H3.
		Eq: apply Aux to Eq.
			Aux: assert forall (A : ty -> ty) B, nabla x, A = B -> A x = B x.
			Eq: apply Aux1 to Eq1.
			apply IH to H5 _ Eq2 with A = x\ m\ A2 x m n2, x = n1.
				backchain mono_weaken_ty. search.
		search.

Theorem typeSubst :
	(forall F E FE FxE m X C, nabla x,
		append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
		mono E m -> chk (FxE x) (X x) (C x) -> chk (FE m) (X m) (C m)) /\
	(forall F E FE FxE m X C, nabla x,
		append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
		mono E m -> inf (FxE x) (X x) (C x) -> inf (FE m) (X m) (C m)) /\
	(forall F E FE FxE m X B C, nabla x,
		append (F x) E (FE x) -> append (F x) (tyvar x :: E) (FxE x) ->
		mono E m -> infApp (FxE x) (B x) (X x) (C x) -> infApp (FE m) (B m) (X m) (C m)).
induction on 4 4 4. split.
	intros. D: case H4.
		W: apply mono_wfta to _. /* GEN_BY_SCRIPT 
		W: applys mono_wfta. */ 
			W: apply wftm_strenthen_tyvar_notfresh to H1 _ _ _. /* GEN_BY_SCRIPT 
			W: applys wftm_strenthen_tyvar_notfresh H1. */ 
			search.
		A: assert append (tyvar n2 :: F n1) E (tyvar n2 :: FE n1).
			D: apply IH to A _ _ D with x = n1.
			W: apply mono_wft to H3. /* GEN_BY_SCRIPT 
			W: applys mono_wft H3. */ 
			apply wft_strenthen_tyvar_notfresh to H1 H2 D1 W. /* GEN_BY_SCRIPT 
			applys wft_strenthen_tyvar_notfresh H1 H2 D1 W. */ 
			search.
		A: assert append (of n2 (A n1) :: F n1) E (of n2 (A n1) :: FE n1).
			W: apply wft_wfta to D.
			D: apply IH to A _ _ D1 with x = n1.
			W: apply mono_wft to H3.
			W: apply wft_strenthen_tyvar_notfresh to H1 H2 D _. search.
		D: apply IH1 to _ _ _ D1.
			S: apply sub_substM to _ _ _ D2. /* GEN_BY_SCRIPT 
			S: applys sub_substM D2. */
			All: assert notAll_ (C m).
				W: apply sub_wft to D2. W: case W1. search. search. search. search.
					M: case H3. search. search. search.
					search.
					M: case H3. search. search. search.
					search.
					apply notAll_false to D.
			search.
	intros. D: case H4.
		apply mono_prune_tm to H3.
			M: apply member_of_subst to D with A = x\ y\ m x.
			A: apply append_subst to H1 with A = m1.
			M: assert member (of n2 (A1 m1)) (FE n2 m1).
				A: apply append_subst to H2 with A = m1.
				M: apply append_mem_inv to A1 _. M: case M1.
				backchain append_mem. M: case M1. backchain append_mem.
			search.
		D: apply IH to _ _ _ D. search.
		apply IH to _ _ _ D1. /* GEN_BY_SCRIPT 
		applys IH. */ 
			W: apply mono_wft to H3. /* GEN_BY_SCRIPT 
			W: applys mono_wft H3. */ 
			apply wft_strenthen_tyvar_notfresh to _ _ D W. /* GEN_BY_SCRIPT 
			applys wft_strenthen_tyvar_notfresh D W. */ 
			search.
		search.
		W: apply mono_wfta to D. W: case W.
			D: apply IH to _ _ _ D1.
			M: apply mono_strenthen_tyvar_notfresh to _ _ D H3. search.
		D: apply IH1 to _ _ _ D.
			D: apply IH2 to _ _ _ D1. search.
		D: apply IH1 to _ _ _ D1. /* GEN_BY_SCRIPT 
		D: applys IH1. */ 
			W: apply mono_wft to H3. /* GEN_BY_SCRIPT 
			W: applys mono_wft H3. */ 
			W: apply wft_strenthen_tyvar_notfresh to _ _ D W. /* GEN_BY_SCRIPT 
			W: applys wft_strenthen_tyvar_notfresh D W. */ 
			search.
		D: apply IH1 to _ _ _ D1. /* GEN_BY_SCRIPT 
		D: applys IH1. */ 
			W: apply mono_wft to H3. /* GEN_BY_SCRIPT 
			W: applys mono_wft H3. */ 
			W: apply wft_strenthen_tyvar_notfresh to _ _ D W. /* GEN_BY_SCRIPT 
			W: applys wft_strenthen_tyvar_notfresh D W. */ 
			search.
	intros. D: case H4.
		D: apply IH2 to _ _ _ D.
			M: apply mono_strenthen_tyvar_notfresh to _ _ D1 H3.
			W: apply mono_wft to H3. /* GEN_BY_SCRIPT 
			W: applys mono_wft H3. */ 
			apply wft_strenthen_tyvar_notfresh to _ _ _ _. /* GEN_BY_SCRIPT 
			applys wft_strenthen_tyvar_notfresh. */  search.
		D: apply IH to _ _ _ D.
			W: apply mono_wft to H3.
			W: apply wft_strenthen_tyvar_notfresh to _ _ D1 W. search.
		W: apply mono_wfta to H3. /* GEN_BY_SCRIPT 
		W: applys mono_wfta H3. */ 
			apply wftm_strenthen_tyvar_notfresh to _ _ _ _. /* GEN_BY_SCRIPT 
			applys wftm_strenthen_tyvar_notfresh. */ 
			search.

Split typeSubst as typeSubst_chk, typeSubst_inf, typeSubst_infApp.


% ex_free + wfj -> wfta -> wft
Define esub : olist -> olist -> prop by
	esub nil nil;
	esub (j J :: E) (j J :: F) := esub E F;
	nabla x, esub (tyvar x :: E) (tyvar x :: F) := esub E F;
	nabla x, esub (styvar x :: E) (styvar x :: F) := esub E F;
	nabla t, esub (of t A0 :: E) (of t A :: F) := sub F A0 A /\ esub E F.

Theorem wfj_exFree_wfta_wft : forall E A, wfj E -> exFree E -> wfta E A -> wft E A.
induction on 3. intros. case H3. % Manual Fix try search.
search. search. search. search. search.
	apply exFree_false to _ H2.
	apply IH to _ _ H4. apply IH to _ _ H5. search.
	apply IH to _ _ H4. backchain exFree_tyvar. search.

Theorem esub_eq : forall E, wfj E -> exFree E -> esub E E.
induction on 1. intros. W: case H1. search.
	F: apply exFree_weaken to H2. J: apply IH to W _. search.
	F: apply exFree_weaken to H2. J: apply IH to W _. search.
	apply exFree_false to _ H2.
	F: apply exFree_weaken to H2. W: apply wfj_exFree_wfta_wft to _ _ W1.
		D: apply sub_refl to _. J: apply IH to W _. search.
	F: apply exFree_weaken to H2. J: apply IH to W _. search.

Theorem esub_tyvar : forall E F, nabla x,
	esub (E x) (F x) -> member (tyvar x) (E x) -> member (tyvar x) (F x).
induction on 1. intros. case H1. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H4 _. search.

Theorem esub_styvar : forall E F, nabla x,
	esub (E x) (F x) -> member (styvar x) (E x) -> member (styvar x) (F x).
induction on 1. intros. case H1. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	search.
	case H2. apply IH to H4 _. search.

Theorem esub_mono : forall E F m, esub E F -> mono E m -> mono F m.
induction on 2. intros. case H2. search.
	apply esub_tyvar to H1 _. search.
	apply IH to _ H3. apply IH to _ H4. search.

Theorem esub_wft : forall E F m, esub E F -> wft E m -> wft F m.
induction on 2. intros. case H2. % Manual Fix try search.
search. search. search.
	apply esub_tyvar to H1 _. search.
	apply esub_styvar to H1 _. search.
	apply IH to _ H3. apply IH to _ H4. search.
	apply IH to _ H3. search.

Theorem esub_pruneF : forall E F, nabla (x : ty),
	esub E (F x) -> exists Fr, F = x\ Fr.
induction on 1. intros. case H1. % Manual Fix
	search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H3.
		apply sub_wft to H2. /* GEN_BY_SCRIPT 
		applys sub_wft H2. */  apply wft_prune to H5. /* GEN_BY_SCRIPT  applys wft_prune H5. */  search.

Theorem esub_pruneE : forall E F, nabla (x : ty),
	esub (E x) F -> exists Er, E = x\ Er.
induction on 1. intros. case H1. % Manual Fix
	search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H3.
		apply sub_wft to H2. /* GEN_BY_SCRIPT 
		applys sub_wft H2. */  apply wft_prune to H4. /* GEN_BY_SCRIPT  applys wft_prune H5. */  search.


Theorem esub_sub : forall E F A B,
	esub E F -> sub E A B -> sub F A B.
induction on 2. intros. case H2. search.
	apply esub_wft to _ H3. /* GEN_BY_SCRIPT 
	applys esub_wft H3. */  search.
	apply esub_wft to _ H3. /* GEN_BY_SCRIPT 
	applys esub_wft H3. */  search.
	apply esub_tyvar to H1 _. search.
	apply esub_styvar to H1 _. /* GEN_BY_SCRIPT 
	applys esub_styvar H1. */  search.
	apply IH to _ H3. /* GEN_BY_SCRIPT 
	applys IH H3. */  apply IH to _ H4. /* GEN_BY_SCRIPT  applys IH H4. */  search.
	apply IH to _ H3. /* GEN_BY_SCRIPT 
	applys IH. */  apply esub_mono to H1 _. /* GEN_BY_SCRIPT  applys esub_mono H1. */  search.
	apply IH to _ H3. /* GEN_BY_SCRIPT 
	applys IH. */  search.

Theorem esub_tyvar_inv : forall E F, nabla x,
	esub (F x) (E x) -> member (tyvar x) (E x) -> member (tyvar x) (F x).
induction on 1. intros. case H1. % Manual Fix
	case H2.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. search. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H4 _. search.

Theorem esub_styvar_inv : forall E F, nabla x,
	esub (F x) (E x) -> member (styvar x) (E x) -> member (styvar x) (F x).
induction on 1. intros. case H1. % Manual Fix
	case H2.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. apply IH to H3 _. search.
	case H2. search. search.
	case H2. apply IH to H4 _. search.

Theorem esub_mono_inv : forall E F m, esub F E -> mono E m -> mono F m.
induction on 2. intros. case H2. search.
	apply esub_tyvar_inv to H1 _. search.
	apply IH to _ H3. apply IH to _ H4. search.

Theorem esub_wft_inv : forall E F m, esub F E -> wft E m -> wft F m.
induction on 2. intros. case H2. search.
	search. search.
	apply esub_tyvar_inv to H1 _. search.
	apply esub_styvar_inv to H1 _. search.
	apply IH to _ H3. apply IH to _ H4. search.
	apply IH to _ H3. search.

Theorem esub_sub_inv : forall E F A B,
	esub F E -> sub E A B -> sub F A B.
induction on 2. intros. case H2. search.
	W: apply esub_wft_inv to _ H3. /* GEN_BY_SCRIPT 
	W: applys esub_wft_inv H3. */  search.
	W: apply esub_wft_inv to _ H3. /* GEN_BY_SCRIPT 
	W: applys esub_wft_inv H3. */  search.
	apply esub_tyvar_inv to H1 _. search.
	apply esub_styvar_inv to H1 _. search.
	apply IH to _ H3. /* GEN_BY_SCRIPT 
	applys IH H3. */  apply IH to _ H4. /* GEN_BY_SCRIPT  applys IH H4. */  search.
	apply IH to _ H3. /* GEN_BY_SCRIPT 
	applys IH. */  apply esub_mono_inv to H1 _. /* GEN_BY_SCRIPT  applys esub_mono_inv H1. */  search.
	apply IH to _ H3. /* GEN_BY_SCRIPT 
	applys IH. */  search.

Theorem esub_of : forall E F A, nabla t,
	esub (E t) (F t) -> member (of t A) (E t) ->
	exists A0, nabla t, member (of t A0) (F t) /\ sub (F t) A A0.
induction on 1. intros. case H1.
	case H2.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: apply sub_weaken_f to _ H6 with EF = j (J n1) :: F1 n1. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_f H6 with EF = j (J n1) :: F1 n1. */  search.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: apply sub_weaken_ty to H6. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_ty H6. */  search.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: apply sub_weaken_sty to H6. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_sty H6. */  search.
	case H2. apply IH to H4 _.
		apply member_prune_tm to H5. apply member_prune_tm to H6.
		W: apply sub_wft to H3. W: apply esub_wft_inv to H4 _.
		D: apply sub_weaken_of to H7 with X = A1 n1. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_of H7 with X = A1 n1. */  search.
	case H2.
		W: apply sub_wft to H3. D: apply sub_weaken_of to H3 with X = A1. /* GEN_BY_SCRIPT  D: applys sub_weaken_of H3 with X = A1. */  search.
		apply member_prune_tm to H5.

Theorem esub_of_inv : forall E F A, nabla t,
	esub (F t) (E t) -> member (of t A) (E t) ->
	exists A0, nabla t, member (of t A0) (F t) /\ sub (F t) A0 A.
induction on 1. intros. case H1.
	case H2.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: apply sub_weaken_f to _ H6 with EF = j (J n1) :: E1 n1. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_f H6 with EF = j (J n1) :: E1 n1. */  search.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: apply sub_weaken_ty to H6. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_ty H6. */  search.
	case H2. apply IH to H3 H4.
		apply member_prune to H4. apply member_prune to H5.
		D: apply sub_weaken_sty to H6. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_sty H6. */  search.
	case H2. apply IH to H4 _.
		apply member_prune_tm to H5. apply member_prune_tm to H6.
		W: apply sub_wft to H3. W: apply esub_wft_inv to H4 _.
		D: apply sub_weaken_of to H7 with X = A0 n1. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_of H7 with X = A0 n1. */  search.
	case H2.
		W: apply sub_wft to H3. D: apply sub_weaken_of to H3 with X = A1. /* GEN_BY_SCRIPT  D: applys sub_weaken_of H3 with X = A1. */ 
		D: apply esub_sub_inv to _ D. /* GEN_BY_SCRIPT 
		D: applys esub_sub_inv D. */  search.
		apply member_prune_tm to H5.

Theorem esub_exFree : forall E F, esub E F -> exFree E /\ exFree F.
induction on 1. intros. case H1.
	apply exFree_nil. search.
	apply IH to H2. /* GEN_BY_SCRIPT 
	applys IH. */  split. backchain exFree_j. backchain exFree_j.
	apply IH to H2. /* GEN_BY_SCRIPT 
	applys IH. */  split. backchain exFree_tyvar. backchain exFree_tyvar.
	apply IH to H2. /* GEN_BY_SCRIPT 
	applys IH. */  split. backchain exFree_styvar. backchain exFree_styvar.
	apply IH to H3. /* GEN_BY_SCRIPT 
	applys IH. */  split. backchain exFree_of. backchain exFree_of.

Theorem esub_wfta_wft : forall E F A, esub E F -> wfta E A -> wft E A.
intros E W.
	Ex: apply esub_exFree to _. /* GEN_BY_SCRIPT 
	Ex: applys esub_exFree. */ 
	apply exFree_wfta_wft to _ _. /* GEN_BY_SCRIPT 
	applys exFree_wfta_wft. */  search.

Theorem esub_wfta_wft_F : forall E F A, esub E F -> wfta F A -> wft F A.
intros E W.
	Ex: apply esub_exFree to _. /* GEN_BY_SCRIPT 
	Ex: applys esub_exFree. */ 
	apply exFree_wfta_wft to _ _. /* GEN_BY_SCRIPT 
	applys exFree_wfta_wft. */  search.

Theorem esub_wftm_inv : forall E F X, esub E F -> wftm F X -> wftm E X.
induction on 2. intros. case H2. search.
	apply esub_of_inv to H1 _. search.
	W: apply esub_wfta_wft_F to _ _. /* GEN_BY_SCRIPT 
	W: applys esub_wfta_wft_F. */ 
		S: apply sub_refl to W. /* GEN_BY_SCRIPT 
		S: applys sub_refl W. */ 
		W: apply esub_wft_inv to _ _. /* GEN_BY_SCRIPT 
		W: applys esub_wft_inv. */  W: apply wft_wfta to W1. /* GEN_BY_SCRIPT  W: applys wft_wfta W1. */ 
		apply IH to _ H4. /* GEN_BY_SCRIPT 
		applys IH. */  search.
	apply IH to _ H4. /* GEN_BY_SCRIPT 
	applys IH. */ 
	apply IH to _ H3. apply IH to _ H4. search.
	apply IH to _ H3.
		W: apply esub_wfta_wft_F to _ _. /* GEN_BY_SCRIPT 
		W: applys esub_wfta_wft_F. */ 
		W: apply esub_wft_inv to _ _. /* GEN_BY_SCRIPT 
		W: applys esub_wft_inv. */  W: apply wft_wfta to W1. /* GEN_BY_SCRIPT  W: applys wft_wfta W1. */ 
		search.
	apply IH to _ H3. /* GEN_BY_SCRIPT 
	applys IH. */ 
		W: apply esub_wfta_wft_F to _ _. /* GEN_BY_SCRIPT 
		W: applys esub_wfta_wft_F. */ 
		W: apply esub_wft_inv to _ _. /* GEN_BY_SCRIPT 
		W: applys esub_wft_inv. */  W: apply wft_wfta to W1. /* GEN_BY_SCRIPT  W: applys wft_wfta W1. */ 
		search.
	apply IH to _ H3. /* GEN_BY_SCRIPT 
	applys IH. */ 
		W: apply esub_wfta_wft_F to _ H4. /* GEN_BY_SCRIPT 
		W: applys esub_wfta_wft_F H4. */ 
		W: apply esub_wft_inv to _ W. /* GEN_BY_SCRIPT 
		W: applys esub_wft_inv W. */  W: apply wft_wfta to W1. /* GEN_BY_SCRIPT  W: applys wft_wfta W1. */ 
		search.

Define tyExt : olist -> olist -> olist -> olist -> prop by
	tyExt E E F F;
	nabla x, tyExt E (tyvar x :: Ex) F (tyvar x :: Fx) := tyExt E Ex F Fx.

Theorem tyExt_esub : forall E F Ex Fx, tyExt E Ex F Fx -> esub E F -> esub Ex Fx.
induction on 1. intros. case H1. search.
	apply IH to H3 _. search.

Theorem tyExt_env : forall E F Ex Fx, tyExt E Ex F Fx -> env E -> env F -> env Ex /\ env Fx.
induction on 1. intros. case H1. search.
	apply IH to H4 _ _. search.


Define tmSize : tm -> nat -> prop by
	tmSize unit (s z);
	nabla x, tmSize x (s z);
	tmSize (lam X) (s N) := nabla x, tmSize (X x) N;
	tmSize (app X Y) (s K) := exists M N, tmSize X M /\ tmSize Y N /\ add M N K;
	tmSize (anno X A) (s N) := tmSize X N;
	tmSize (tApp X A) (s N) := tmSize X N;
	tmSize (tAnno X A) (s N) := nabla x, tmSize (X x) N.

Theorem tmSize_prune : forall X N, nabla (x : ty),
	tmSize (X x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search. search.
	apply IH to H2. search.
	apply IH to H2. apply IH to H3. apply add_prune_k[ty] to H4. search.
	apply IH to H2 with x = n1. search.
	apply IH to H2 with x = n1. search.
	apply IH to H2 with x = n1. search.

Theorem tmSize_prune_tm : forall X N, nabla (x : tm),
	tmSize (X x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search. search. search.
	apply IH to H2 with x = n1. search.
	apply IH to H2. apply IH to H3. apply add_prune_k[tm] to H4. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem tmSize_subst : forall X A N, nabla (x : ty),
	tmSize (X x) N -> tmSize (X (A x)) N.
induction on 1. intros. case H1. search. search.
	apply IH to H2 with A = A. search.
	apply tmSize_prune to H2. apply IH to H2 with A = A.
		apply tmSize_prune to H3. apply IH to H3 with A = A. search.
	apply IH to H2 with A = A. search.
	apply IH to H2 with A = A. search.
	apply IH to H2 with A = A. search.

Theorem tmSize_det : forall X N1 N2, tmSize X N1 -> tmSize X N2 -> N1 = N2.
induction on 1. intros. case H1.
	case H2. search. case H2. search.
	case H2. apply IH to H3 H4. search.
	case H2. apply IH to H3 H6. apply IH to H4 H7. apply add_det to H5 H8. search.
	case H2. apply IH to H3 H4. search.
	case H2. apply IH to H3 H4. search.
	case H2. apply IH to H3 H4. search.

Theorem tmSize_is_nat : forall X N, tmSize X N -> is_nat N.
induction on 1. intros. case H1. search. search.
	apply IH to H2. search.
	apply IH to H3. apply add_is_nat_k to H5 H4. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem tmSize_total : forall E X, wftm E X -> exists N, tmSize X N.
induction on 1. intros. case H1. search. search.
	apply IH to H3. apply tmSize_prune_tm to H4. search.
	apply IH to H2. apply IH to H3. apply tmSize_is_nat to H4.
		apply add_total to H6 with n = N1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. apply tmSize_prune to H4. /* GEN_BY_SCRIPT  applys tmSize_prune H4. */  search.

Theorem lt_sm : forall m n, lt (s m) n -> exists N, n = s N /\ lt m N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.

Theorem tmSize_s : forall X N, tmSize X N -> exists n, N = s n.
intros. case H1. % Manual Fix
search. search. search. search. search. search. search.

Theorem order_total_wft_thm : forall E A, wft E A -> exists N, order A N.
induction on 1. intros. case H1. % Manual Fix try search.
 search. search. search. search. search. 
	apply IH to H2. apply IH to H3. apply order_is_nat to H4.
		apply add_total to H6 with n = N1. search.
	apply IH to H2. apply order_prune to H4. search.

Theorem order_total_wft_N : forall E A, wft E A -> exists N, order A N /\ is_nat N.
intros. apply order_total_wft_thm to H1. apply order_is_nat to H2. search.

%%%%%%%%%%%%%%%%%%%% Typing Properties %%%%%%%%%%%%%%%%%%%%
Theorem chkInfApp_weaken :
	(forall E F G EG EFG X A, 
		append E G EG -> split3 E F G EFG -> chk EG X A -> chk EFG X A) /\
	(forall E F G EG EFG X A,
		append E G EG -> split3 E F G EFG -> inf EG X A -> inf EFG X A) /\
	(forall E F G EG EFG X A C,
		append E G EG -> split3 E F G EFG -> infApp EG A X C -> infApp EFG A X C).
induction on 3 3 3. split.
	intros. case H3.
		W: apply wftm_weaken to _ H2 _. /* GEN_BY_SCRIPT 
		W: applys wftm_weaken H2. */  search.
		S: apply split3_cons to H2 with X = tyvar n1.
			D: apply IH to _ S H4. W: apply wft_weaken to _ _ _. /* GEN_BY_SCRIPT  W: applys wft_weaken. */  search.
		S: apply split3_cons to H2 with X = of n1 A1.
			W: apply wft_weaken to H1 H2 H4.
			D: apply IH to _ S H5. search.
		S: apply IH1 to _ _ H5.
			D: apply sub_weaken to H1 H2 H6. /* GEN_BY_SCRIPT 
			D: applys sub_weaken H1 H2 H5. */  search.
	intros. case H3.
		M: assert member (of n1 A1) (EFG n1).
			M: apply append_mem_inv to _ H4. M: case M.
			backchain split3_mem. backchain split3_mem.
			search.
		apply IH to _ _ H4. search.
		S: apply split3_cons to H2 with X = tyvar n1. /* GEN_BY_SCRIPT 
		S: applys split3_cons H2 with X = tyvar n1. */ 
			apply IH to _ S H5. /* GEN_BY_SCRIPT 
			applys IH S. */ 
			W: apply wft_weaken to _ _ _. /* GEN_BY_SCRIPT 
			W: applys wft_weaken. */ 
			search.
		search.
		S: apply split3_cons to H2 with X = of n1 M1.
			M: apply mono_weaken to H1 H2 _.
			W: apply mono_wft to M. W: case W.
			D: apply IH to _ S H5. search.
		D: apply IH1 to _ _ H4.
			D: apply IH2 to _ _ H5. search.
		D: apply IH1 to _ _ H5. /* GEN_BY_SCRIPT 
		D: applys IH1. */  apply wft_weaken to _ _ _. /* GEN_BY_SCRIPT  applys wft_weaken. */  search.
		D: apply IH1 to _ _ H5. /* GEN_BY_SCRIPT 
		D: applys IH1. */  apply wft_weaken to _ _ _. /* GEN_BY_SCRIPT  applys wft_weaken. */  search.
	intros. case H3.
		M: apply mono_weaken to H1 H2 _.
			D: apply IH2 to _ _ H4.
			apply wft_weaken to _ _ _. /* GEN_BY_SCRIPT 
			applys wft_weaken. */  search.
		W: apply wft_weaken to H1 H2 H5.
			D: apply IH to _ _ H4. search.
		W: apply wftm_weaken to _ _ _. /* GEN_BY_SCRIPT 
		W: applys wftm_weaken. */  search.

Split chkInfApp_weaken as chk_weaken, inf_weaken, infApp_weaken.

Theorem chk_weaken_f : forall F E FE X A,
	chk E X A -> append F E FE -> chk FE X A.
intros. T: apply chk_weaken to _ _ H1. search.
Theorem chk_weaken_ex : forall E X A, nabla x,
	chk E X A -> chk (exvar x :: E) X A.
intros. backchain chk_weaken_f with F = exvar n1 :: nil.
Theorem chk_weaken_ty : forall E X A, nabla x,
	chk E X A -> chk (tyvar x :: E) X A.
intros. backchain chk_weaken_f with F = tyvar n1 :: nil.
Theorem chk_weaken_sty : forall E X A, nabla x,
	chk E X A -> chk (styvar x :: E) X A.
intros. backchain chk_weaken_f with F = styvar n1 :: nil.
Theorem chk_weaken_of : forall E X A T, nabla x,
	chk E X A -> chk (of x T :: E) X A.
intros. backchain chk_weaken_f with F = of n1 T :: nil.

Theorem inf_weaken_f : forall F E FE X A,
	inf E X A -> append F E FE -> inf FE X A.
intros. T: apply inf_weaken to _ _ H1. search.
Theorem inf_weaken_ex : forall E X A, nabla x,
	inf E X A -> inf (exvar x :: E) X A.
intros. backchain inf_weaken_f with F = exvar n1 :: nil.
Theorem inf_weaken_ty : forall E X A, nabla x,
	inf E X A -> inf (tyvar x :: E) X A.
intros. backchain inf_weaken_f with F = tyvar n1 :: nil.
Theorem inf_weaken_sty : forall E X A, nabla x,
	inf E X A -> inf (styvar x :: E) X A.
intros. backchain inf_weaken_f with F = styvar n1 :: nil.
Theorem inf_weaken_of : forall E X A T, nabla x,
	inf E X A -> inf (of x T :: E) X A.
intros. backchain inf_weaken_f with F = of n1 T :: nil.

Theorem infApp_weaken_f : forall F E FE A X C,
	infApp E A X C -> append F E FE -> infApp FE A X C.
intros. T: apply infApp_weaken to _ _ H1. search.
Theorem infApp_weaken_ex : forall E A X C, nabla x,
	infApp E A X C -> infApp (exvar x :: E) A X C.
intros. backchain infApp_weaken_f with F = exvar n1 :: nil.
Theorem infApp_weaken_ty : forall E A X C, nabla x,
	infApp E A X C -> infApp (tyvar x :: E) A X C.
intros. backchain infApp_weaken_f with F = tyvar n1 :: nil.
Theorem infApp_weaken_sty : forall E A X C, nabla x,
	infApp E A X C -> infApp (styvar x :: E) A X C.
intros. backchain infApp_weaken_f with F = styvar n1 :: nil.
Theorem infApp_weaken_of : forall E A X C T, nabla x,
	infApp E A X C -> infApp (of x T :: E) A X C.
intros. backchain infApp_weaken_f with F = of n1 T :: nil.


Theorem wft_strenthen_of : forall F E FE FxE A T, nabla x,
	append F E FE -> append F (of x T :: E) (FxE x) ->
	wft (FxE x) A -> wft FE A.
induction on 3. intros. W: case H3. search.
	search. search.
	M: apply append_mem_inv to _ W. M: case M.
		apply append_mem to H1 _. search. M: case M. apply append_mem to H1 _. search.
	M: apply append_mem_inv to _ W. M: case M.
		apply append_mem to H1 _. search. M: case M. apply append_mem to H1 _. search.
	W: apply IH to H1 H2 W. W: apply IH to H1 H2 W1. search.
	W: apply IH to _ _ W with F = tyvar n2 :: F, FE = tyvar n2 :: FE. search.

Theorem wft_remove_of : forall E A T, nabla x,
	wft (of x T :: E) A -> wft E A.
intros. apply wft_strenthen_of to _ _ H1 with FE = E. search.


Theorem wfj_of_wfta : forall E A, nabla x,
	wfj (E x) -> member (of x A) (E x) -> wfta (E x) A.
induction on 2. intros. case H2.
	case H1. backchain wfta_weaken_of.
	assert append (B n1 :: nil) (L n1) (B n1 :: L n1).
		apply wfj_rev to H1. apply IH to _ H3.
		backchain wfta_weaken_f.

Theorem exFree_of_wft : forall E A, nabla x,
	wfj (E x) -> exFree (E x) -> member (of x A) (E x) -> wft (E x) A.
intros. apply wfj_of_wfta to H1 H3.
	backchain wfj_exFree_wfta_wft.

Theorem wfj_of_det : forall E A A1, nabla x,
	wfj (E x) -> member (of x A) (E x) -> member (of x A1) (E x) -> A = A1.
induction on 1. intros. case H1. case H2.
	case H2. case H3. apply IH to H4 H5 H6. search.
	case H2. case H3. apply IH to H4 H5 H6. search.
	case H2. case H3. apply IH to H4 H5 H6. search.
	case H2. case H3. apply IH to H4 H7 H6. search.
	case H2. case H3. search. apply member_prune_tm to H6. apply member_prune_tm to H6.
	case H2. case H3. apply IH to H4 H6 H7. search.

Theorem chkInfApp_wft :
	(forall E X A, chk E X A -> wfj E -> exFree E -> wft E A) /\
	(forall E X A, inf E X A -> wfj E -> exFree E -> wft E A) /\
	(forall E X A C, infApp E A X C -> wfj E -> exFree E -> wft E A /\ wft E C).
induction on 1 1 1. split.
	intros. case H1 (keep). search. search.
		W: apply wft_wfta to H4. apply IH to H5 _ _. backchain exFree_of.
			W: apply wft_remove_of to H6. search.
		apply sub_wft to H6. search.
	intros. case H1 (keep).
		backchain exFree_of_wft.
		apply IH to H4 _ _. search.
		apply IH to H5 _ _. /* GEN_BY_SCRIPT 
		applys IH. */  backchain exFree_tyvar. search.
		search.
		W: apply mono_wft to H4. search.
		apply IH2 to H5 _ _. search.
		apply IH1 to H5 _ _. /* GEN_BY_SCRIPT 
		applys IH1. */  search.
		apply IH1 to H5 _ _. /* GEN_BY_SCRIPT 
		applys IH1. */  W: apply wft_open_a to _ H6 H4. /* GEN_BY_SCRIPT  W: applys wft_open_a H6 H4. */  search.
	intros. case H1.
		apply IH2 to H4 _ _.
			W: apply wft_weaken_f to _ H6 with EF = tyvar n1 :: E.
			search.
			% W: apply wft_subst to W _ with T = A1, m = n1. search.
		apply IH to H4 _ _. search.
		search.

Split chkInfApp_wft as chk_wft, inf_wft, infApp_wft.

Theorem chkInfApp_wftm :
	(forall E X A, chk E X A -> wfj E -> exFree E -> wftm E X) /\
	(forall E X A, inf E X A -> wfj E -> exFree E -> wftm E X) /\
	(forall E X A C, infApp E A X C -> wfj E -> exFree E -> wftm E X).
induction on 1 1 1. split.
	intros. case H1. search.
		apply IH to H4 _ _. backchain exFree_tyvar.
			apply wftm_strenthen_tyvar to _ _ H6 _. /* GEN_BY_SCRIPT 
			applys wftm_strenthen_tyvar H6. */  search.
		W: apply wft_wfta to H4. apply IH to H5 _ _. backchain exFree_of.
			search.
		apply IH1 to H5 _ _. /* GEN_BY_SCRIPT 
		applys IH1. */  search.
	intros. case H1.
		search.
		apply IH to H4 _ _. /* GEN_BY_SCRIPT 
		applys IH. */ 
			Ts: apply chkInfApp_wft.
			W: apply Ts to _ _ _. /* GEN_BY_SCRIPT 
			W: applys Ts. */  W: apply wft_wfta to W. /* GEN_BY_SCRIPT  W: applys wft_wfta W. */ 
			search.
		apply IH to H5 _ _. /* GEN_BY_SCRIPT 
		applys IH. */  backchain exFree_tyvar.
			W: case H4. W: apply wft_wfta to W. /* GEN_BY_SCRIPT  W: applys wft_wfta W. */ 
			search.
		search.
		M: case H4. W: apply mono_wfta to M. /* GEN_BY_SCRIPT  W: applys mono_wfta M. */ 
			apply IH to H5 _ _. /* GEN_BY_SCRIPT 
			applys IH. */  backchain exFree_of.
			search.
		W: apply IH1 to H4 _ _. /* GEN_BY_SCRIPT 
		W: applys IH1. */  W: apply IH2 to H5 _ _. /* GEN_BY_SCRIPT  W: applys IH2. */  search.
		W: apply IH1 to H5 _ _. /* GEN_BY_SCRIPT 
		W: applys IH1. */  W: apply wft_wfta to H4. /* GEN_BY_SCRIPT  W: applys wft_wfta H4. */  search.
		W: apply IH1 to H5 _ _. /* GEN_BY_SCRIPT 
		W: applys IH1. */  W: apply wft_wfta to H4. /* GEN_BY_SCRIPT  W: applys wft_wfta H4. */  search.
	intros. case H1.
		apply IH2 to H4 _ _. /* GEN_BY_SCRIPT 
		applys IH2. */  search.
		apply IH to H4 _ _. /* GEN_BY_SCRIPT 
		applys IH H4. */  search.
		search.

Split chkInfApp_wftm as chk_wftm, inf_wftm, infApp_wftm.



Define subSize : olist -> ty -> ty -> nat -> prop by	
	subSize E i i z;
	subSize E A top z := wft E A;
	subSize E bot A z := wft E A;
	nabla x, subSize (E x) x x z := nabla x, member (tyvar x) (E x);
	nabla x, subSize (E x) x x z := nabla x, member (styvar x) (E x);
	subSize E (arrow A1 A2) (arrow B1 B2) (s K) := exists M N,
		subSize E B1 A1 M /\ subSize E A2 B2 N /\ add M N K;
	subSize E (all A) B (s N) :=
			exists m, subSize E (A m) B N /\ mono E m /\ notAll_ B /\ inFV A;
	subSize E (all A) (all B) (s N) :=
			nabla x, subSize (styvar x :: E) (A x) (B x) N /\ inFV A /\ inFV B.

Theorem subSize_sub : forall E A B N, subSize E A B N -> sub E A B.
induction on 1. intros. case H1. % Manual Fix try search.
 search. search. search. search. search. 
	apply IH to H2. apply IH to H3. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem subSize_is_nat : forall E A B N, subSize E A B N -> is_nat N.
induction on 1. intros. case H1. % Manual Fix try search.
 search. search. search. search. search.
	apply IH to H3. apply add_is_nat_k to _ H4. search.
	apply IH to H2. search.
	apply IH to H2. search.

Theorem subSize_prune : forall E A B N, nabla (x : ty),
	subSize (E x) (A x) (B x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. % Manual Fix try search.
 search. search. search. search. search. search. search.
	apply IH to H2. apply IH to H3. apply add_prune_k to H4. search.
	apply IH to H2. search.
	apply IH to H2 with x = n1. search.

Theorem subSize_total : forall E A B, sub E A B -> exists N, subSize E A B N.
induction on 1. intros. case H1. % Manual Fix try search.
 search. search. search. search. search.
	apply IH to H2. apply IH to H3.
		N: apply subSize_is_nat to H4. apply add_total to N with n = N1. search.
	apply IH to H2. search.
	apply IH to H2. apply subSize_prune to H5. search.

Theorem subSize_weaken : forall E F G T1 T2 EG EFG N,
	append E G EG -> split3 E F G EFG ->
	subSize EG T1 T2 N -> subSize EFG T1 T2 N.
induction on 3. intros. case H3.
	search.
	apply wft_weaken to _ _ _. /* GEN_BY_SCRIPT 
	applys wft_weaken. */  search.
	apply wft_weaken to _ _ _. /* GEN_BY_SCRIPT 
	applys wft_weaken. */  search.
	apply mem_GE_GFE to _ _ H4. /* GEN_BY_SCRIPT 
	applys mem_GE_GFE H4. */  search.
	apply mem_GE_GFE to _ _ H4. /* GEN_BY_SCRIPT 
	applys mem_GE_GFE H4. */  search.
	apply IH to _ _ H4. /* GEN_BY_SCRIPT 
	applys IH H4. */  apply IH to _ _ H5. /* GEN_BY_SCRIPT  applys IH H5. */  search.
	apply IH to _ _ H4. /* GEN_BY_SCRIPT 
	applys IH H4. */  apply mono_weaken to _ _ H5. /* GEN_BY_SCRIPT  applys mono_weaken H5. */  search.
	S: apply split3_cons to H2 with X = styvar n1. /* GEN_BY_SCRIPT 
	S: applys split3_cons H2 with X = styvar n1. */ 
		apply IH to _ S H4. /* GEN_BY_SCRIPT 
		applys IH S. */  search.
Theorem subSize_weaken_f : forall E F EF T1 T2 N,
	append E F EF -> subSize F T1 T2 N -> subSize EF T1 T2 N.
intros. backchain subSize_weaken with E = nil, F = E, G = F.
Theorem subSize_weaken_fx : forall E X T1 T2 N,
	subSize E T1 T2 N -> subSize (X :: E) T1 T2 N.
intros. backchain subSize_weaken_f with E = X :: nil, F = E.


Theorem wft_higher_order_prune : forall (A : ty -> ty -> ty) m1 m2 E Ar, nabla x,
			wft E (A m1 m2) -> A x m2 = Ar -> exists Ar', A = x\ Ar'.
Aux: assert forall A (B : ty), A = B -> B = A.
induction on 1. intros W Eq. W: case W.
	case W (keep). % Manual Fix case Eq; search.
		case Eq. search. case Eq. search.
	case W (keep). % Manual Fix case Eq; search.
		case Eq. search. case Eq. search.
	case W (keep). % Manual Fix case Eq; search.
		case Eq. search. case Eq. search.
	case W (keep). % Manual Fix case Eq; search.
		case Eq. search. case Eq. search.
	case W (keep). % Manual Fix case Eq; search.
		case Eq. search. case Eq. search.
	case W (keep). % Manual Fix Eq: case Eq; try search.
		Eq: case Eq.
		Eq: apply Aux to Eq. Eq: apply Aux to Eq1.
		apply IH to W1 _ with A = A2. /* GEN_BY_SCRIPT 
		applys IH W1 with A = A2. */  apply IH to W2 _ with A = A3. /* GEN_BY_SCRIPT  applys IH W2 with A = A3. */ 
		search.
		Eq: case Eq. search.
	case W (keep). % Manual Fix Eq: case Eq; try search.
		Eq: case Eq.
		Eq: apply Aux to Eq. % abella fail: applys IH W1 with A = x\ y\ A4 x y n1.
		Aux: assert forall A (B : ty -> ty), nabla x, A = B -> A x = B x.
		Eq: apply Aux1 to Eq1. permute (n1 n2) Eq2.
		apply IH to W1 Eq2 with A = x\ y\ A2 x y n1, x = n2.
		search.
		Eq: case Eq. search.

Theorem sub_inst_bot : forall E A m,
	sub E (A m) bot -> mono E m -> exists Ar, A = x\ Ar.
induction on 1. intros S M. W: apply sub_wft to S. /* GEN_BY_SCRIPT  W: applys sub_wft S. */  S: case S.
	case S. search. case M.
	case S. % Manual Fix try solve case M.
	Eq: apply IH to S1 _ with A = x\ A2 x m1. /* GEN_BY_SCRIPT 
	Eq: applys IH with A = x\ A2 x m1. */ 
		Aux: assert forall A (B : ty -> ty), nabla x, A = B -> A x = B x.
		Eq: apply Aux to Eq.
		W: apply sub_wft to S1. /* GEN_BY_SCRIPT 
		W: applys sub_wft S1. */ 
		apply wft_higher_order_prune to W2 _ with A = A2. /* GEN_BY_SCRIPT 
		applys wft_higher_order_prune W2 with A = A2. */ 
		search.
	case M.

Theorem sub_all_bot_false : forall E A, sub E (all A) bot -> false.
induction on 1. intros. case H1.
	apply sub_inst_bot to H2 _ with A = A. /* GEN_BY_SCRIPT 
	applys sub_inst_bot H2 with A = A. */ 
	case H5. apply H6 to _. /* GEN_BY_SCRIPT  applys H6. */ 

Theorem sub_trans_thm : forall E A B C n N S1 S2 ns Ns,
	order B n -> lt n N -> is_nat N ->
	subSize E A B S1 -> subSize E B C S2 ->
	add S1 S2 ns -> lt ns Ns -> is_nat Ns ->
	wfj E -> sub E A C.
induction on 3. induction on 8. intros.
	D: apply subSize_sub to H5.
	D: case H4 (keep). % Manual Fix try search.
	search.
		D: case D. search.
			% N: case H5. case H6. L: applys lt_sm H7.
			% N: case H8.
			% S: applys subSize_weaken_fx H4 with X = tyvar n1.
			% applys IH1 S N. search.
		W: apply sub_wft to D. /* GEN_BY_SCRIPT 
			% N: case H5. case H6. L: applys lt_sm H7.
			% N: case H8.
			% S: applys subSize_weaken_fx H4 with X = tyvar n1.
			% applys IH1 S N. search.
		W: applys sub_wft D. */  search.
		search. search.
		% A1 -> A2 <: B1 -> B2
		clear D. N: apply subSize_is_nat to H5. D: case H5.
			% top
			S: apply subSize_sub to D1. /* GEN_BY_SCRIPT 
			% top
			S: applys subSize_sub D1. */  S: apply subSize_sub to D2. /* GEN_BY_SCRIPT  S: applys subSize_sub D2. */ 
				W: apply sub_wft to S. /* GEN_BY_SCRIPT 
				W: applys sub_wft S. */  W: apply sub_wft to S1. /* GEN_BY_SCRIPT  W: applys sub_wft S1. */ 
				search.
			% A1 -> A2 <: B1 -> B2 <: B3 -> B4
			P: case H6. P: apply add_s_inv to *P.
				P: apply add_assoc4 to D3 D5 _.
				L: apply lt_sm to *H7. L: apply lt_sm to *L.
				IS: case H8. IS: case IS.
				N: case N. N: apply add_is_nat_k to _ P.
				L: apply add_le to _ P3.
				L: apply le_trans to _ L1 _. L: apply le_trans to _ L2 _.
				N: apply order_is_nat to H1. O: case H1. L: apply add_le to _ O2.
				L: apply le_trans to _ L5 _. L: apply le_trans to _ L6 _.
				D: apply IH1 to _ L7 H3 _ _ P1 _ IS _.
				D: apply IH1 to _ L8 H3 _ _ P2 _ IS _.
				search.
			% A1 -> A2 <: B1 -> B2 <: \forall a. B3
			% D: apply subSize_weaken_f to _ H4 with EF = tyvar n1 :: E.
			% 	P: apply add_s_inv to *H6.
			% 	L: apply lt_sm to H7. IS: case H8.
			% 	D: apply IH1 to _ H2 H3 D4 D P _ IS. search.
	% \forall x. A <: B
	P: case H6. L: apply lt_sm to *H7.
		IS: case H8.
		D: apply IH1 to _ _ H3 _ _ P _ IS _.
		D: case D (keep). % Manual fix
			search. search.
			D: apply subSize_sub to D1. /* GEN_BY_SCRIPT 
			D: applys subSize_sub D1. */ 
			Gen: assert forall E A C N, order A N -> is_nat N ->
					sub E A bot -> wft E C -> sub E A C.
				induction on 2. intros O N S W. W: apply sub_wft to S. /* GEN_BY_SCRIPT  W: applys sub_wft S. */  S: case S (keep).
					search.
					O: case O. N: case N.
					O: apply order_subst to _ S2 O with A = A3. /* GEN_BY_SCRIPT 
					O: applys order_subst O _ S2 with A = A3. */ 
						S: apply IH2 to _ N S1 _. /* GEN_BY_SCRIPT 
						S: applys IH2 S1. */ 
						W: case W1.
						W: case W (keep). search. search. search. search. search. search.
						apply sub_inst_bot to S1 _ with A = A3. /* GEN_BY_SCRIPT 
						applys sub_inst_bot S1 with A = A3. */ 
						apply inFV_false to W3. /* GEN_BY_SCRIPT 
						applys inFV_false W3. */
			S: apply subSize_sub to H4. /* GEN_BY_SCRIPT 
			S: applys subSize_sub H4. */ 
				W: apply sub_wft to S. /* GEN_BY_SCRIPT 
				W: applys sub_wft S. */ 
				O: apply order_total_wft to W. /* GEN_BY_SCRIPT 
				O: applys order_total_wft W. */ 
				N: apply order_is_nat to O. /* GEN_BY_SCRIPT 
				N: applys order_is_nat O. */ 
			backchain Gen.
			search. search. search.
			apply notAll_false to _. apply notAll_false to _.
	% A <: \forall x. B
	D: case H5.
		% top
		S: apply subSize_sub to H4. /* GEN_BY_SCRIPT 
		% top
		S: applys subSize_sub H4. */  W: apply sub_wft to S. /* GEN_BY_SCRIPT  W: applys sub_wft S. */  search.
		% A <: \forall x. B <: C
		D: apply subSize_sub to D1.
			W: apply mono_wft to D5. /* GEN_BY_SCRIPT 
			W: applys mono_wft D5. */ 
			W: apply wft_weaken_f to _ W with E = styvar n1 :: nil. /* GEN_BY_SCRIPT 
			W: applys wft_weaken_f W with E = styvar n1 :: nil. */ 
			D: apply sub_subst_wft to W1 D8 _ _. /* GEN_BY_SCRIPT 
			D: applys sub_subst_wft W1 D8. */  
			D: apply subSize_total to D9. apply subSize_prune to D10. /* GEN_BY_SCRIPT  applys subSize_prune D10. */ 
			N: apply subSize_is_nat to D10. P: apply add_total to N with n = N2.
			N: apply add_is_nat_k to _ P. backchain subSize_is_nat.
			O: case H1. O: apply order_subst to _ D5 O with A = B1.
			L: apply lt_sm to *H2. IO: case H3.
			D: apply subSize_weaken_f to _ D4 with E = styvar n1 :: nil. /* GEN_BY_SCRIPT 
			D: applys subSize_weaken_f D4 with E = styvar n1 :: nil. */ 
			D: apply IH to _ _ IO D10 D11 P _ _ _ with Ns = s k.
			D: apply sub_strenthen_styvar_f to D12. /* GEN_BY_SCRIPT 
			D: applys sub_strenthen_styvar_f D12. */ 
			search.
		% A <: \forall x. B <: \forall x. C
		P: apply add_s_inv to *H6. /* GEN_BY_SCRIPT 
		% A <: \forall x. B <: \forall x. C
		P: applys add_s_inv *H6. */  P: case P.
			lt: apply lt_sm to *H7. /* GEN_BY_SCRIPT 
			lt: applys lt_sm *H7. */  lt: apply lt_sm to *lt. /* GEN_BY_SCRIPT  lt: applys lt_sm *lt. */ 
			O: case H1. lt: apply lt_sm to *H2. /* GEN_BY_SCRIPT  lt: applys lt_sm *H2. */  IN: case H3.
			N: case H8.
			apply IH to _ _ IN D1 D4 P _ N _. /* GEN_BY_SCRIPT 
			applys IH D1 D4 P N. */  search.
		% D: apply subSize_weaken_f to _ H4 with EF = tyvar n1 :: E.
		% 	P: apply add_s_inv to *H6.
		% 	L: apply lt_sm to H7. IS: case H8.
		% 	D: apply IH1 to _ H2 H3 D3 D2 P _ IS. search.

Theorem sub_trans : forall E A B C,
	sub E A B -> sub E B C -> wfj E -> sub E A C.
intros. D: apply subSize_total to H1. D: apply subSize_total to H2.
	W: apply sub_wft to H1. /* GEN_BY_SCRIPT 
	W: applys sub_wft H1. */ 
	O: apply order_total_wft_N to W1.
	N: apply subSize_is_nat to D. N: apply subSize_is_nat to D1.
	P: apply add_total to N with n = N1. N: apply add_is_nat_k to _ P.
	D: apply sub_trans_thm to O _ _ D D1 _ _ _ _ with N = s N2, Ns = s k.
	search.

% Theorem sub_allR_inv : forall E A B, nabla x,
% 	sub E A (all B) -> sub (tyvar x :: E) A (B x).
% induction on 1. intros. case H1.
% 	W: case H2. search.
% 	apply IH to H2. M: apply mono_weaken_ty to H3. search.
% 	search.

Theorem mono_sty_ty : forall F E FtyE FstyE M, nabla x,
	append (F x) (tyvar x :: E) (FtyE x) -> append (F x) (styvar x :: E) (FstyE x) ->
	mono (FstyE x) M -> mono (FtyE x) M.
induction on 3. intros. case H3. search.
	apply mem_FxE_FyE to H2 _ _ _ _. /* GEN_BY_SCRIPT 
	applys mem_FxE_FyE H2. */  search.
	apply IH to _ _ H4. /* GEN_BY_SCRIPT 
	applys IH H4. */  apply IH to _ _ H5. /* GEN_BY_SCRIPT  applys IH H5. */  search.

Theorem sub_sty_ty : forall F E FtyE FstyE A B, nabla x,
	append (F x) (tyvar x :: E) (FtyE x) -> append (F x) (styvar x :: E) (FstyE x) ->
	sub (FstyE x) (A x) (B x) -> wfj (FstyE x) -> sub (FtyE x) (A x) (B x).
induction on 3. intros A A S. S: case S.
	search.
	apply wft_sty_ty to _ _ S. /* GEN_BY_SCRIPT 
	applys wft_sty_ty S. */  search.
	apply wft_sty_ty to _ _ S. /* GEN_BY_SCRIPT 
	applys wft_sty_ty S. */  search.
	apply mem_FxE_FyE to A1 _ _ _ _. /* GEN_BY_SCRIPT 
	applys mem_FxE_FyE A1. */  search.
	apply mem_FxE_FyE to A1 _ _ _ _. /* GEN_BY_SCRIPT 
	applys mem_FxE_FyE A1. */  search.
	apply mem_FxE_FyE to A1 _ _ _ _. /* GEN_BY_SCRIPT 
	applys mem_FxE_FyE A1. */  search.
	apply mem_FxE_FyE to A1 _ _ _ _. /* GEN_BY_SCRIPT 
	applys mem_FxE_FyE A1. */  search.
	apply IH to _ _ S _. /* GEN_BY_SCRIPT 
	applys IH S. */  apply IH to _ _ S1 _. /* GEN_BY_SCRIPT  applys IH S1. */  search.
	S: apply IH to _ _ S _. /* GEN_BY_SCRIPT 
	S: applys IH S. */ 
		apply mono_prune_styvar to _ _ _. /* GEN_BY_SCRIPT 
		applys mono_prune_styvar. */  backchain append_mem.
		M: apply mono_sty_ty to A A1 _. /* GEN_BY_SCRIPT 
		M: applys mono_sty_ty A A1. */ 
		search.
	S: apply IH to _ _ S _. /* GEN_BY_SCRIPT 
	S: applys IH. */  search.


Theorem subsumption_thm :
	(forall E' E X Nx NX NO A A',
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat (s z) ->
			order (arrow A A') NO -> is_nat NO ->
		esub E' E -> chk E X A ->
		sub E A A' -> wfj E -> exFree E ->
		chk E' X A') /\
	(forall E' E X Nx NX A,
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat z ->
		esub E' E -> inf E X A -> wfj E -> exFree E ->
		exists A', sub E A' A /\ inf E' X A') /\
	(forall E' E X Nx NX NO A C C',
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat (s (s z)) ->
			order (arrow C C') NO -> is_nat NO ->
		esub E' E -> infApp E C X A ->
		sub E C' C -> wfj E -> exFree E ->
		exists A', sub E A' A /\ infApp E' C' X A').
induction on 2 2 2. IJ: induction on 4 4 4. clear IJ2. split.
	IO: induction on 6. intros. case H8.
		% e <== top
		S: case H9.
			% top <: top
				apply esub_wftm_inv to _ _. /* GEN_BY_SCRIPT 
			% top <: top
				applys esub_wftm_inv. */ 
				search.
			% top <: \forall b. B
				% O: case H5. O: case O1. case O. case O2.
				% IO: case H6.
				% D: applys IO H2 H4 IO1 S with X = X.
				% 	backchain exFree_tyvar.
				% 		applys wftm_weaken_ty H12. search.
				% 	search.
		% e <== \forall a. A1
		D: case H9.
			% top
				Ex: apply exFree_tyvar to H11. /* GEN_BY_SCRIPT 
			% top
				Ex: applys exFree_tyvar H11. */ 
				W: apply chk_wftm to H12 _ _. /* GEN_BY_SCRIPT 
				W: applys chk_wftm H12. */  W: apply wftm_strenthen_tyvar_notfresh to _ _ W _. /* GEN_BY_SCRIPT  W: applys wftm_strenthen_tyvar_notfresh W. */ 
				case D.
				W: apply esub_wftm_inv to _ _. /* GEN_BY_SCRIPT 
				W: applys esub_wftm_inv. */  search.
			% (A1 m) <: A'
			% M: applys mono_nil_any D1 with E = E.
			D: apply typeSubst_chk to _ _ D1 _. /* GEN_BY_SCRIPT 
			% (A1 m) <: A'
			% M: applys mono_nil_any D1 with E = E.
			D: applys typeSubst_chk D1. */ 
				O: case H5. O: case O. O: apply order_subst to _ _ O with A = A1. P: case O2.
				IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ _ _ _ _. search.
			% \forall a. A1 <: \forall b. B
			O: case H5. O: case O. O: case O1.
				P: case O2. P: apply add_s_inv to *P. /* GEN_BY_SCRIPT  P: applys add_s_inv *P. */ 
				IO: case H6. IO: case IO1.
				D: apply sub_sty_ty to _ _ D _. /* GEN_BY_SCRIPT 
				D: applys sub_sty_ty D. */ 
				D: apply IO to _ H2 _ H4 _ IO1 _ _ D3 _ _. /* GEN_BY_SCRIPT 
				D: applys IO D3. */  backchain exFree_tyvar.
				W: apply sub_wft to D3. /* GEN_BY_SCRIPT 
				W: applys sub_wft D3. */  W: apply esub_wft_inv to _ W1. /* GEN_BY_SCRIPT  W: applys esub_wft_inv W1. */ 
				search.
			% D: assert chk E X (all A1). D: apply chk_weaken_ty to D1.
			% 	O: case H5. O: case O1. P: apply add_s_inv to O2.
			% 	IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ D2 _ _ _.
			% 		backchain exFree_tyvar. search.
		% \x. e <== A1 -> B
		D: case H9.
			% top
				Ex: apply exFree_of to H11 with A = A1. /* GEN_BY_SCRIPT 
			% top
				Ex: applys exFree_of H11 with A = A1. */ 
				W: apply wft_wfta to H12. /* GEN_BY_SCRIPT 
				W: applys wft_wfta H12. */ 
				W: apply chk_wftm to H13 _ _. /* GEN_BY_SCRIPT 
				W: applys chk_wftm H13. */ 
				W: apply esub_wftm_inv to _ _ with X = lam X1. /* GEN_BY_SCRIPT 
				W: applys esub_wftm_inv with X = lam X1. */  search.
			% A1 -> B <: B1 -> B2
			T: case H1. L: apply lt_sm to *H3. IT: case H2.
				D: apply sub_weaken_of to D1 with X = A1. /* GEN_BY_SCRIPT 
				D: applys sub_weaken_of D1 with X = A1. */ 
				O: apply order_total to D2. N: apply order_is_nat to O.
				D: apply IH to _ IT _ _ O _ _ H13 D2 _ _.
					backchain exFree_of. W: apply wft_wfta to H12. search.
				D: apply esub_sub_inv to _ D. /* GEN_BY_SCRIPT 
				D: applys esub_sub_inv D. */  W: apply sub_wft to D4. search.
			% % A1 -> B <: \forall b. B1
			% D: assert chk E X (arrow A1 B). D: apply chk_weaken_ty to D1.
			% 	O: case H5. O: case O1. P: apply add_s_inv to O2.
			% 	IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ D2 _ _ _.
			% 		backchain exFree_tyvar. search.
		% e <== A
		J: case H4 (keep). W: apply sub_wft to H14.
			D: apply IJ1 to _ H2 _ J _ H13 _ _.
			D: assert sub E A'1 A'. backchain sub_trans. backchain sub_trans.
			D: apply esub_sub_inv to _ D2. /* GEN_BY_SCRIPT 
			D: applys esub_sub_inv D2. */
			W: case W1.
				case H9. search. search.
				case H9. search.
				W: apply sub_wft to H9.
				W: case W2. search. search. search. search. search. search.
				% bot <: forall
					O: case H5. O: case O1.
					P: apply add_s_inv to _.
					IO: case H6.
					S: assert sub (tyvar n1 :: E) bot (A2 n1).
					D: apply 2 IO to _ H2 _ H4 _ IO1 _ _ S _ _.
						backchain exFree_tyvar. backchain chk_weaken_ty.
					W: apply sub_wft to D3.
					search.
				case H9. search. search. search.
				case H9. search. search. search.
				case H9. search. search.
				apply notAll_false to H12.
	intros. Ts: apply chkInfApp_wft. D: case H6.
		D: apply esub_of_inv to _ D. D: apply esub_sub to _ D2. /* GEN_BY_SCRIPT  D: applys esub_sub D2. */  search.
		W: apply Ts to D _ _. D: apply sub_refl to W.
			T: case H1. L: apply lt_sm to *H3. IT: case H2.
			O: apply order_total to D1. N: apply order_is_nat to O.
			D: apply IH to _ IT _ _ O _ _ _ _ _ _. search.
		W: apply Ts to D1 _ _. backchain exFree_tyvar.
			D: apply sub_refl to W.
			T: case H1. L: apply lt_sm to *H3. IT: case H2.
			O: apply order_total to D2. N: apply order_is_nat to O.
			D: assert esub (tyvar n1 :: E') (tyvar n1 :: E).
			D: apply IH to _ IT _ _ O _ D3 _ _ _ _. /* GEN_BY_SCRIPT 
			D: applys IH O D3. */  backchain exFree_tyvar.
			S: apply sub_refl to D. /* GEN_BY_SCRIPT 
			S: applys sub_refl D. */ 
			W: apply esub_wft_inv to _ D. /* GEN_BY_SCRIPT 
			W: applys esub_wft_inv D. */ 
			search.
		search.
		W: apply mono_wft to D. W: case W (keep).
			D: apply sub_refl to W1. D: apply sub_refl to W.
			W: case W. D: apply sub_refl to W2.
			D: apply esub_sub_inv to _ D3. /* GEN_BY_SCRIPT 
			D: applys esub_sub_inv D3. */ 
			D: apply sub_weaken_of to D4 with X = M1. /* GEN_BY_SCRIPT 
			D: applys sub_weaken_of D4 with X = M1. */ 
			T: case H1. L: apply lt_sm to *H3. IT: case H2.
			O: apply order_total to D4. N: apply order_is_nat to O.
			D: apply IH to _ IT _ _ O _ _ D1 _ _ _.
				backchain exFree_of. W: apply wft_wfta to W1. search.
			M: apply esub_mono_inv to _ D. search.
		N: apply tmSize_is_nat to H1. T: case H1. L: apply lt_sm to *H3. IT: case H2.
			N: case N. L: apply add_le to _ T2.
			L: apply le_trans to _ L1 _. L: apply le_trans to _ L2 _.
			D: apply IH1 to T IT _ _ _ D _ _.
			O: apply order_total to D2. N: apply order_is_nat to O.
			O: case O. P: apply add_comm to _ O2. backchain order_is_nat.
			D: apply IH2 to T1 IT _ _ _ N1 _ D1 _ _ _. search.
		T: case H1. lt: apply lt_sm to *H3. /* GEN_BY_SCRIPT  lt: applys lt_sm *H3. */  IT: case H2.
			W: apply esub_wft_inv to _ D. /* GEN_BY_SCRIPT 
			W: applys esub_wft_inv D. */ 
			D: apply IH1 to _ IT _ _ _ _ _ _. /* GEN_BY_SCRIPT 
			D: applys IH1. */  D: case D2 (keep).
				search.
				exists A1 B. apply sub_inst_bot to D4 _ with A = A1. /* GEN_BY_SCRIPT  applys sub_inst_bot D4 with A = A1. */  search.
		T: case H1. lt: apply lt_sm to *H3. /* GEN_BY_SCRIPT  lt: applys lt_sm *H3. */  IT: case H2.
			D: apply IH1 to _ IT _ _ _ _ _ _. /* GEN_BY_SCRIPT 
			D: applys IH1. */  D: case D2 (keep).
				exists bot. W: apply esub_wft_inv to _ D. /* GEN_BY_SCRIPT  W: applys esub_wft_inv D. */  D: apply wft_open_a to _ D4 D. /* GEN_BY_SCRIPT  D: applys wft_open_a D4 D. */  search.
				apply notAll_false to _. /* GEN_BY_SCRIPT 
				applys notAll_false. */ 
				exists A2 B.
					W: apply wft_weaken_f to _ D with E = styvar n1 :: nil. /* GEN_BY_SCRIPT 
					W: applys wft_weaken_f D with E = styvar n1 :: nil. */ 
					D: apply sub_subst_wft to W D4 _ _. /* GEN_BY_SCRIPT 
					D: applys sub_subst_wft D4 W. */ 
					D: apply sub_strenthen_styvar_f to D7. /* GEN_BY_SCRIPT 
					D: applys sub_strenthen_styvar_f D7. */ 
					W: apply esub_wft_inv to _ D. /* GEN_BY_SCRIPT 
					W: applys esub_wft_inv D. */ 
					search.

	IO: induction on 6. intros. D: case H8 (keep).
		D: case H9.
			W: apply infApp_wft to H8 _ _. /* GEN_BY_SCRIPT 
			W: applys infApp_wft H8. */ 
				W: apply infApp_wftm to H8 _ _. /* GEN_BY_SCRIPT 
				W: applys infApp_wftm H8. */  W: apply esub_wftm_inv to _ W2. /* GEN_BY_SCRIPT  W: applys esub_wftm_inv W2. */ 
				search. % bot
			apply notAll_false to _. /* GEN_BY_SCRIPT  % bot
			applys notAll_false. */ 
			W: apply mono_wft to D1. /* GEN_BY_SCRIPT 
			W: applys mono_wft D1. */ 
				W: apply wft_weaken_f to _ W with E = styvar n1 :: nil. /* GEN_BY_SCRIPT 
				W: applys wft_weaken_f W with E = styvar n1 :: nil. */ 
				D: apply sub_subst_wft to W1 D3 _ _. /* GEN_BY_SCRIPT 
				D: applys sub_subst_wft D3 W1. */ 
				O: case H5. O: case O. O: apply order_subst to _ _ O with A = A1. P: case O2.
					O: case O1. O: apply order_subst to _ _ O1 with A = A2. /* GEN_BY_SCRIPT  O: applys order_subst O1 with A = A2. */  P: apply add_s_inv to *P. /* GEN_BY_SCRIPT  P: applys add_s_inv *P. */ 
				IO: case H6. IO: case IO1.
				D: apply sub_strenthen_styvar_f to D6. /* GEN_BY_SCRIPT 
				D: applys sub_strenthen_styvar_f D6. */ 
				D: apply IO to _ H2 _ H4 _ IO1 _ D _ _ _.
				W: apply sub_wft to D3. /* GEN_BY_SCRIPT 
				W: applys sub_wft D3. */ 
				W: assert wft E (all A2).
					apply wft_sty_ty to _ _ W2. /* GEN_BY_SCRIPT 
					applys wft_sty_ty W2. */  search.
				W: apply esub_wft_inv to _ W4. /* GEN_BY_SCRIPT 
				W: applys esub_wft_inv W4. */ 
				M: apply esub_mono_inv to _ D1. /* GEN_BY_SCRIPT 
				M: applys esub_mono_inv D1. */ 
				search.
		D: case H9.
			W: apply chk_wftm to D _ _. /* GEN_BY_SCRIPT 
			W: applys chk_wftm D. */  W: apply esub_wftm_inv to _ _. /* GEN_BY_SCRIPT  W: applys esub_wftm_inv. */  search.
			J: case H4.
			O: apply order_total to D2. N: apply order_is_nat to O.
				D: apply IJ to _ H2 _ J O _ _ _ _ _ _.
				W: apply sub_wft to D3. W: apply esub_wft_inv to _ W. search.
			O: case H5. O: case O1.
				O: apply order_subst to _ _ O1 with A = A2. P: apply add_s_inv to O2.
				IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ _ _ _ _.
				M: apply mono_nil_any to _ with E = E'. /* GEN_BY_SCRIPT 
				M: applys mono_nil_any with E = E'. */ 
				W: apply sub_wft to D2. /* GEN_BY_SCRIPT 
				W: applys sub_wft D2. */  W: apply wft_unsubst_all to _ _. /* GEN_BY_SCRIPT  W: applys wft_unsubst_all. */ 
				W: apply esub_wft_inv to _ W2. /* GEN_BY_SCRIPT 
				W: applys esub_wft_inv W2. */ 
				M: apply esub_mono_inv to _ D3. /* GEN_BY_SCRIPT 
				M: applys esub_mono_inv D3. */ 
				search.
		W: apply esub_wftm_inv to _ _. /* GEN_BY_SCRIPT 
		W: applys esub_wftm_inv. */  D: case H9.
			search.
			O: case H5. O: case O. O: case O1.
				O: apply order_subst to _ _ O with A = A1. case O2.
				IO: case H6. D: apply IO to _ H2 _ H4 _ IO1 _ _ _ _ _.
				M: apply mono_nil_any to _ with E = E'. /* GEN_BY_SCRIPT 
				M: applys mono_nil_any with E = E'. */ 
				W: apply sub_wft to D1. /* GEN_BY_SCRIPT 
				W: applys sub_wft D1. */  W: apply wft_unsubst_all to _ _. /* GEN_BY_SCRIPT  W: applys wft_unsubst_all. */ 
				W: apply esub_wft_inv to _ W3. /* GEN_BY_SCRIPT 
				W: applys esub_wft_inv W3. */ 
				M: apply esub_mono_inv to _ D2. /* GEN_BY_SCRIPT 
				M: applys esub_mono_inv D2. */ 
				search.

Theorem chk_subsumption : forall E' E X A A' F,
	esub E' E -> chk E X A -> sub E A A' -> wftm F X -> wfj E -> exFree E -> chk E' X A'.
intros.
	S: apply subsumption_thm. clear S1. clear S2.
	T: apply tmSize_total to H4. N: apply tmSize_is_nat to T.
	O: apply order_total to H3. N: apply order_is_nat to O.
	D: apply S to _ _ _ _ O _ H1 H2 H3 _ _. search.

Theorem chkLam_inversion : forall E X A B, nabla t,
	chk E (lam X) (arrow A B) -> wfj E -> exFree E -> wftm E (lam X) ->
		chk (of t A :: E) (X t) B.
intros. D: case H1. search.
	D: case D1. W: apply sub_wft to D2.
		D: case D2.
		E: apply esub_eq to H2 _.
		E: assert esub (of n1 A :: E) (of n1 M1 :: E).
		W: case W. W: case H4.
		D: apply sub_weaken_of to D4 with X = M1. /* GEN_BY_SCRIPT 
		D: applys sub_weaken_of D4 with X = M1. */ 
		D: apply chk_subsumption to E1 D3 D5 _ _ _.
			backchain exFree_of. W: apply wft_wfta to W. search.
		search.

Theorem chkLamAll_inversion : forall E X A, nabla x,
	chk E (lam X) (all A) -> wfj E -> exFree E -> wftm E (lam X) ->
	chk (tyvar x :: E) (lam X) (A x).
intros. case H1 (keep). search.
	apply notAll_false to H5.


%%%%%%%%%%%% Equivalent non-overlapping declarative system %%%%%%%%%%%%
Define sub' : olist -> ty -> ty -> prop by
	sub' E i i;
	sub' E A top := wft E A;
	sub' E bot A := wft E A;
	nabla x, sub' (E x) x x := nabla x, member (tyvar x) (E x);
	nabla x, sub' (E x) x x := nabla x, member (styvar x) (E x);
	sub' E (arrow A1 A2) (arrow B1 B2) := sub' E B1 A1 /\ sub' E A2 B2;
	sub' E (all A) B := (B = top -> false) /\ notAll_ B /\ inFV A /\
											exists m, sub' E (A m) B /\ mono E m;
	sub' E (all A) (all B) := nabla x, sub' (styvar x :: E) (A x) (B x) /\ inFV A /\ inFV B.

Theorem sub'_complete_thm : forall E A B n N,
	wfj E -> sub E A B ->
	order (arrow A B) n -> lt n N -> is_nat N ->
	exFree E -> sub' E A B.
induction on 5. induction on 2. intros. case H2 (keep). % Manual Fix try search.
 search. search. search. search. search.
	N: apply order_is_nat to H3.
		O: case H3. O: case O. O: case O1. P: apply add_assoc4 to _ _ O2.
		L: apply add_le to _ P2. L: apply le_trans to _ L _. L: apply le_trans to _ L1 _.
		D: apply IH1 to _ H7 _ L2 H5 _. D: apply IH1 to _ H8 _ L3 H5 _. search.
	O: case H3. O: case O. O: apply order_subst to _ H8 O with A = A1.
		P: case O2 (keep). L: apply lt_sm to *H4. OI: case H5.
		D: apply IH to _ H7 _ _ OI _.
		W: apply sub_wft to H2. /* GEN_BY_SCRIPT 
		W: applys sub_wft H2. */  W: case W1. search. search. search. search. search. search. search.
	O: case H3. O: case O1. P: apply add_s_inv to *O2.
		O: case O. P: case P.
		L: apply lt_sm to *H4. L: apply lt_sm to *L. /* GEN_BY_SCRIPT  L: applys lt_sm *L. */  OI: case H5. OI: case OI.
		D: apply IH to _ H7 _ _ OI _.
		backchain exFree_styvar.
		W: apply sub_wft to H2. /* GEN_BY_SCRIPT 
		W: applys sub_wft H2. */  W: case W. search.

Theorem sub'_complete : forall E A B,
	sub E A B -> wfj E -> exFree E -> sub' E A B.
intros. apply order_total to H1. apply order_is_nat to H4.
	apply sub'_complete_thm to _ _ _ _ _ _ with N = s m. /* GEN_BY_SCRIPT 
	applys sub'_complete_thm with N = s m. */  search.

Theorem sub'_sound : forall E A B, sub' E A B -> sub E A B.
induction on 1. intros. case H1. % Manual Fix try search.
search. search. search. search. search.
	apply IH to H2. apply IH to H3. search.
	apply IH to H5. /* GEN_BY_SCRIPT 
	applys IH. */  search.
	apply IH to H2. /* GEN_BY_SCRIPT 
	applys IH. */  search.


Define chk' : olist -> tm -> ty -> prop,
       inf' : olist -> tm -> ty -> prop,
       infApp' : olist -> ty -> tm -> ty -> prop by
	nabla x, inf' (E x) x A := nabla x, member (of x A) (E x);
	inf' E (anno X A) A := chk' E X A;
	inf' E (tAnno X A) (all A) := nabla x, wft E (all A) /\ chk' (tyvar x :: E) (X x) (A x);
	chk' E unit i;
	inf' E unit i;
	chk' E X top := wftm E X;
	chk' E X (all A) := nabla x, chk' (tyvar x :: E) X (A x) /\ wft E (all A);
	chk' E (lam X) (arrow A B) := nabla x, wft E A /\ chk' (of x A :: E) (X x) B;
	inf' E (lam X) (arrow M1 M2) := nabla x,
		mono E (arrow M1 M2) /\ chk' (of x M1 :: E) (X x) M2;
	inf' E (app X1 X2) C := exists A, inf' E X1 A /\ infApp' E A X2 C;
	inf' E (tApp X B) bot := wft E B /\ inf' E X bot;
	inf' E (tApp X B) (A B) := wft E B /\ inf' E X (all A);
	chk' E X B := (B = top -> false) /\ notAll_ B /\ notLam_ X /\ exists A, inf' E X A /\ sub' E A B;
	infApp' E (all A) X C := exists m, infApp' E (A m) X C /\ mono E m /\ wft E (all A);
	infApp' E (arrow A C) X C := chk' E X A /\ wft E C;
	infApp' E bot X bot := wftm E X.

Theorem chkInfApp'_complete_thm :
	(forall E X Nx NX NO A,
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat (s z) ->
			order A NO -> is_nat NO ->
		wfj E -> exFree E -> wftm E X -> chk E X A -> chk' E X A) /\
	(forall E X Nx NX A,
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat z ->
		wfj E -> exFree E -> wftm E X -> inf E X A -> inf' E X A) /\
	(forall E X Nx NX NO A C,
			tmSize X Nx -> is_nat NX -> lt Nx NX ->
			is_nat (s (s z)) ->
			order C NO -> is_nat NO ->
		wfj E -> exFree E -> wftm E X -> infApp E C X A -> infApp' E C X A).
induction on 2 2 2. IJ: induction on 4 4 4. clear IJ2. split.
	IO: induction on 5. intros. D: case H10 (keep).
		search.
		O: case H5. N: apply order_is_nat to O.
			D: apply 0 IO to H1 H2 _ H4 O _ _ _ _ D.
				backchain wftm_weaken_ty. backchain exFree_tyvar. search.
			search.
		T: case H1. L: apply lt_sm to *H3.
			IT: case H2.
			O: case H5. N: apply order_is_nat to O1.
			D: apply IH to _ IT _ _ _ _ _ _ _ D1 with NO = N2.
				backchain wftm_anyA. backchain exFree_of.
				W: apply wft_wfta to D. search.
			search.
		J: case H4 (keep). D: apply IJ1 to _ H2 _ J _ _ _ D1.
			L: assert forall x a, X = lam x -> A = all a -> chk' E X A.
				intros Eq Eq. case Eq. case Eq1.
				D: apply chkLamAll_inversion to H10 _ _ _.
				O: case H5. N: apply order_is_nat to O.
				D: apply 0 IO to _ H2 _ H4 O _ _ _ _ D4.
					backchain wftm_weaken_ty. backchain exFree_tyvar. search.
				W: apply sub_wft to D2. /* GEN_BY_SCRIPT 
				W: applys sub_wft D2. */ 
				search.
			L: assert forall x a b, X = lam x -> A = arrow a b -> chk' E X A.
				intros Eqx Eqa. case Eqa. case Eqx.
				D: apply chkLam_inversion to H10 _ _ _.
				T: case H1. L: apply lt_sm to *H3. T: case H2.
				O: case H5. N: apply order_is_nat to O1.
				W: apply sub_wft to D2. W: case W1.
				D: apply IH to T T1 _ _ _ _ _ _ _ D4 with NO = N2.
					backchain wftm_anyA. backchain exFree_of.
					W: apply wft_wfta to W1. search.
				search.
			D: apply sub'_complete to D2 _ _. /* GEN_BY_SCRIPT 
			D: applys sub'_complete D2. */  W: apply sub_wft to D2. W: case W1.
				T: case H1. % Manual Fix try search.
				search. search.
					D: case D2. D: case D3. case D1. D: case D3.
					 search. search. search. search.
				T: case H1. % Manual Fix search.
					 search. search. search. search. search. search. search.
				T: case H1. % Manual Fix try search.
				 search. search.
					D: case D2. D: case D3. case D1. search. search. search. search.
				T: case H1. % Manual Fix try search.
				 search. search.
					D: case D2. D: case D3. case D1. D: case D3. case D1.
					 search. search. search. search.
				T: case H1. % Manual Fix try search.
				 search. search.
					D: case D2. D: case D3. case D1. D: case D3. case D1.
					 search. search. search. search.
				T: case H1. % Manual Fix try search.
				 search. search.
					backchain L1.
					 search. search. search. search.
				T: case H1. % Manual Fix try search.
				 search. search.
					backchain L.
					 search. search. search. search.
	intros. D: case H8 (keep).
		search.
		T: case H1. L: apply lt_sm to *H3.
			IT: case H2.
			W: case H7. W: apply exFree_wfta_wft to _ *W1. O: apply order_total_wft_N to W1.
			D: apply IH to _ IT _ _ _ _ _ _ _ D with NO = N2. search.
		T: case H1. L: apply lt_sm to *H3.
			IT: case H2.
			Ex: apply exFree_tyvar to _. /* GEN_BY_SCRIPT 
			Ex: applys exFree_tyvar. */ 
			W: case H7. W: apply exFree_wfta_wft to _ *W1. O: apply order_total_wft_N to W1.
			O: case O. N: case O1.
			D: apply IH to _ IT _ _ _ _ _ _ _ D1 with NO = K. search.
		search.
		T: case H1. L: apply lt_sm to *H3.
			IT: case H2.
			W: case H7. W: apply wfj_exFree_wfta_wft to _ _ W.
			W: apply mono_wft to D. W: case W3. O: apply order_total_wft_N to W4.
			D: apply IH to _ IT _ _ _ _ _ _ _ D1 with NO = N2.
				backchain wftm_anyA. backchain exFree_of.
				W: apply wft_wfta to W3. search.
			search.
		N: apply tmSize_is_nat to H1. T: case H1. L: apply lt_sm to *H3.
			N: case N. L: apply add_le to _ T2.
			N: case H2.
			L: apply le_trans to _ L1 _. L: apply le_trans to _ L2 _.
			W: case H7.
			D: apply IH1 to T N1 _ _ _ _ _ D.
			Ts: apply chkInfApp_wft. W: apply Ts2 to D1 _ _.
			O: apply order_total_wft_N to W2.
			D: apply IH2 to T1 N1 _ _ _ _ _ _ _ D1 with NO = N2.
			search.
		T: case H1. L: apply lt_sm to *H3. /* GEN_BY_SCRIPT  L: applys lt_sm *H3. */  IT: case H2.
			W: case H7.
			D: apply IH1 to _ IT _ _ _ _ _ D1. /* GEN_BY_SCRIPT 
			D: applys IH1 D1. */ 
			search.
		T: case H1. L: apply lt_sm to *H3. /* GEN_BY_SCRIPT  L: applys lt_sm *H3. */  IT: case H2.
			W: case H7.
			D: apply IH1 to _ IT _ _ _ _ _ D1. /* GEN_BY_SCRIPT 
			D: applys IH1 D1. */ 
			search.

	IO: induction on 6. intros. D: case H10 (keep).
		O: case H5. IO: case H6. O: apply order_subst to _ D1 O with A = A1.
			D: apply IO to _ H2 _ H4 _ IO1 _ _ _ D. search.
		J: case H4.
			O: case H5. O: apply order_is_nat to O.
			D: apply IJ to H1 H2 _ J _ _ _ _ _ D with NO = M.
			search.
		search.

Theorem chk'_complete : forall E X A,
	wfj E -> exFree E -> wftm E X -> chk E X A -> chk' E X A.
intros. Ts: apply chkInfApp'_complete_thm.
	T: apply tmSize_total to H3. N: apply tmSize_is_nat to T.
	Ts: apply chkInfApp_wft. apply Ts3 to H4 _ _.
	O: apply order_total_wft_N to H5. backchain Ts with NX = s N.

Theorem inf'_complete : forall E X A,
	wfj E -> exFree E -> wftm E X -> inf E X A -> inf' E X A.
intros. Ts: apply chkInfApp'_complete_thm.
	T: apply tmSize_total to H3. N: apply tmSize_is_nat to T.
	backchain Ts1 with NX = s N.

Theorem infApp'_complete : forall E X A C,
	wfj E -> exFree E -> wftm E X -> infApp E A X C -> infApp' E A X C.
intros. Ts: apply chkInfApp'_complete_thm.
	T: apply tmSize_total to H3. N: apply tmSize_is_nat to T.
	Ts: apply chkInfApp_wft. apply Ts5 to H4 _ _.
	O: apply order_total_wft_N to H5. backchain Ts2 with NX = s N.

Theorem chkInfApp'_sound :
	(forall E X A, wftm E X -> chk' E X A -> chk E X A) /\
	(forall E X A, wftm E X -> inf' E X A -> inf E X A) /\
	(forall E X A C, wftm E X -> infApp' E C X A -> infApp E C X A).
induction on 2 2 2. split.
	intros. case H2. search. search.
		apply 0 IH to _ H3. backchain wftm_weaken_ty. search.
		apply IH to _ H4. backchain wftm_anyA. search.
		apply IH1 to _ H6. apply sub'_sound to H7. search.
	intros. case H2. search.
		W: case H1. apply IH to _ H3. search.
		W: case H1. apply IH to _ H4. /* GEN_BY_SCRIPT  applys IH. */  search.
		search.
		W: apply mono_wft to H3. W: case W.
			apply IH to _ H4. backchain wftm_anyA. search.
		W: case H1. apply IH1 to _ H3. apply IH2 to _ H4. search.
		W: case H1. apply IH1 to _ H4. /* GEN_BY_SCRIPT  applys IH1. */  search.
		W: case H1. apply IH1 to _ H4. /* GEN_BY_SCRIPT  applys IH1. */  search.
	intros. case H2.
		apply IH2 to _ H3. search.
		apply IH to _ H3. search.
		search.


Theorem wft_inst : forall E A m,
	wft E (all A) -> wft E m -> wft E (A m).
intros W W. W: case W.
	W: apply wft_subst to W _ with T = A, m = m. /* GEN_BY_SCRIPT 
	W: applys wft_subst W with T = A, m = m. */  backchain wft_weaken_ty.
	apply wft_strenthen_tyvar to _ _ W3. /* GEN_BY_SCRIPT 
	applys wft_strenthen_tyvar W3. */  search.

Theorem wft_inst_mono : forall E A m,
	wft E (all A) -> mono E m -> wft E (A m).
intros. apply mono_wft to H2. /* GEN_BY_SCRIPT  applys mono_wft H2. */  apply wft_inst to H1 H3. /* GEN_BY_SCRIPT  applys wft_inst H1 H3. */  search.
